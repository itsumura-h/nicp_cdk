import std/asyncdispatch
import std/tables
import std/options
import std/strutils
import ../../../../src/nicp_cdk/canisters/management_canister
import ../../../../src/nicp_cdk/ic_types/candid_types
import ../../../../src/nicp_cdk/ic_types/ic_principal
import ../../../../src/nicp_cdk/algorithm/ethereum
import ../../../../src/nicp_cdk/algorithm/ecdsa
import ../../../../src/nicp_cdk/algorithm/hex_bytes
import ./database


proc getNewPublicKey*(caller: Principal): Future[string] {.async.} =
  ## Generates a new public key for the given caller Principal and caches it.
  ## If a public key already exists for the caller, it returns the existing one.
  ##
  ## Parameters:
  ## - caller: The Principal ID of the caller for whom to generate/retrieve the public key.
  ##
  ## Returns:
  ## - The public key as a hexadecimal string.
  if database.hasKey(caller):
    return hex_bytes.toHexString(database.getPublicKey(caller))

  let arg = EcdsaPublicKeyArgs(
    canister_id: none(Principal),
    derivation_path: @[caller.bytes],
    key_id: EcdsaKeyId(
      curve: EcdsaCurve.secp256k1,
      name: "dfx_test_key"
    )
  )
  
  let publicKeyResult = await ManagementCanister.publicKey(arg)
  let publicKeyBytes = publicKeyResult.public_key
  database.setPublicKey(caller, publicKeyBytes)
  let publicKey = hex_bytes.toHexString(publicKeyBytes)
  return publicKey


proc getPublicKey*(caller: Principal): string =
  ## Retrieves the public key for the given caller Principal from the database.
  ##
  ## Parameters:
  ## - caller: The Principal ID of the caller whose public key to retrieve.
  ##
  ## Returns:
  ## - The public key as a hexadecimal string.
  ##
  ## Raises:
  ## - Exception: If no public key has been generated for the caller.
  if database.hasKey(caller):
    let publicKeyBytes = database.getPublicKey(caller)
    return hex_bytes.toHexString(publicKeyBytes)
  else:
    raise newException(Exception, "No public key generated for caller")


proc signWithEcdsa*(caller: Principal, message: string): Future[string] {.async.} =
  ## Signs a message using ECDSA with the caller's derived key.
  ## The signature is generated by the ICP Management Canister and then validated locally.
  ##
  ## Parameters:
  ## - caller: The Principal ID of the caller.
  ## - message: The message to be signed.
  ##
  ## Returns:
  ## - The ECDSA signature as a hexadecimal string if valid, otherwise an empty string.
  let messageHash = ecdsa.keccak256Hash(message)

  let arg = EcdsaSignArgs(
    message_hash: messageHash,
    derivation_path: @[caller.bytes],
    key_id: EcdsaKeyId(
      curve: EcdsaCurve.secp256k1,
      name: "dfx_test_key"
    )
  )

  let signResult = await ManagementCanister.sign(arg)
  
  # Validate the signature using functions from ecdsa.nim
  try:
    let publicKeyBytes = hex_bytes.hexToBytes(getPublicKey(caller))
    let isValid = ecdsa.validateSignatureWithSecp256k1(
      messageHash,
      signResult.signature,
      publicKeyBytes
    )

    if isValid:
      return hex_bytes.toHexString(signResult.signature)
    else:
      return ""
  except Exception:
    # If public key retrieval fails, still return the signature without validation
    return hex_bytes.toHexString(signResult.signature)


proc verifyWithEcdsa*(message: string, signature: string, publicKey: string): bool =
  ## Verifies an ECDSA signature using the provided message, signature, and public key.
  ## This verification uses the functions from the `ecdsa.nim` module.
  ##
  ## Parameters:
  ## - message: The original message that was signed.
  ## - signature: The ECDSA signature as a hexadecimal string.
  ## - publicKey: The public key (hexadecimal string) used for signing.
  ##
  ## Returns:
  ## - True if the signature is valid, False otherwise.
  return ecdsa.verifySignatureWithSecp256k1(message, signature, publicKey)


proc getEvmAddress*(caller: Principal): string =
  try:
    let publicKeyBytes = getPublicKey(caller)
    if publicKeyBytes.len > 0:
      let evmAddress = icpPublicKeyToEvmAddress(hex_bytes.hexToBytes(publicKeyBytes))
      return evmAddress
    else:
      return ""
  except Exception:
    # No public key has been generated for the caller yet
    return ""


proc signWithEthereum*(caller: Principal, message: string): Future[string] {.async.} =
  ## Generates an Ethereum-formatted signature using the ICP Management Canister.
  ## The ICP signature (64 bytes, r+s) is converted to the Ethereum format (65 bytes, r+s+v).
  ## 
  ## Parameters:
  ## - caller: The Principal ID of the caller.
  ## - message: The message to be signed (will be hashed using EIP-191 format).
  ## 
  ## Returns:
  ## - The Ethereum-formatted signature as a hexadecimal string
  ##   (65 bytes, 0x-prefixed 130 hex characters, r(32 bytes) + s(32 bytes) + v(1 byte) format).
  
  # Generate the Ethereum-formatted message hash (EIP-191 format)
  let messageHash = ethereum.keccak256Hash(message)
  
  let arg = EcdsaSignArgs(
    message_hash: messageHash,
    derivation_path: @[caller.bytes],
    key_id: EcdsaKeyId(
      curve: EcdsaCurve.secp256k1,
      name: "dfx_test_key"
    )
  )

  # Generate the signature using the ICP Management Canister
  let signResult = await ManagementCanister.sign(arg)
  
  # Retrieve the public key (needed for Recovery ID calculation)
  let publicKeyBytes = database.getPublicKey(caller)
  if publicKeyBytes.len == 0:
    raise newException(Exception, "Public key not found for caller")
  
  # Convert ICP signature (64 bytes r+s) to Ethereum format (65 bytes r+s+v)
  let ethereumSignature = ethereum.convertIcpSignatureToEthereum(
    signResult.signature,
    messageHash,
    publicKeyBytes
  )
  
  return ethereumSignature



proc verifyWithEthereum*(message: string, signature: string, ethereumAddress: string): bool =
  ## Verifies an Ethereum-formatted signature.
  ## This function hashes the message using the EIP-191 format and attempts to recover the public key
  ## from the signature to verify against the provided Ethereum address.
  ## 
  ## Parameters:
  ## - message: The original message that was signed (will be hashed using EIP-191 format).
  ## - signature: The Ethereum-formatted signature (65 bytes, 0x-prefixed 130 hex characters).
  ## - ethereumAddress: The Ethereum address (0x-prefixed 40 hex characters) of the signer.
  ## 
  ## Returns:
  ## - True if the signature is valid for the given address, False otherwise.
  
  # Verify the Ethereum signature using EIP-191 message hashing
  return ethereum.verifyEthereumSignatureWithAddress(ethereumAddress, message, signature)


proc signWithEvmWallet*(caller: Principal, message: seq[uint8]): Future[string] {.async.} =
  ## Signs a message using the EVM wallet.
  ## 
  ## This function receives a byte array that has already been converted to EIP-191 format
  ## ("\x19Ethereum Signed Message:\n" + message length + message) and hashed with keccak256
  ## on the TypeScript side. Therefore, it directly sends the pre-hashed message to the
  ## ICP Management Canister for signing and converts the result to Ethereum format (65 bytes, r+s+v).
  ## 
  ## Parameters:
  ## - caller: The Principal ID of the caller.
  ## - message: Pre-hashed message in EIP-191 format (32 bytes).
  ## 
  ## Returns:
  ## - Ethereum-formatted signature (65 bytes, 0x-prefixed) as a hexadecimal string.
  let arg = EcdsaSignArgs(
    message_hash: message,
    derivation_path: @[caller.bytes],
    key_id: EcdsaKeyId(
      curve: EcdsaCurve.secp256k1,
      name: "dfx_test_key"
    )
  )

  # Generate the signature using the ICP Management Canister
  let signResult = await ManagementCanister.sign(arg)
  
  # Retrieve the public key (needed for Recovery ID calculation)
  let publicKeyBytes = database.getPublicKey(caller)
  if publicKeyBytes.len == 0:
    raise newException(Exception, "Public key not found for caller")
  
  # Convert ICP signature (64 bytes r+s) to Ethereum format (65 bytes r+s+v)
  let ethereumSignature = ethereum.convertIcpSignatureToEthereum(
    signResult.signature,
    message,
    publicKeyBytes
  )
  
  return ethereumSignature
