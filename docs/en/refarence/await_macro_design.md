# await Macro Design Document

## 1. Overview

This document describes the implementation of `async`/`await`-like macros in Nim, which **automatically transform procedural code into callback functions**.

This macro is **syntactic sugar** that allows asynchronous calls using callback functions in ICP canisters to be written as linear procedural code. The implementation is provided in `src/asyncwasm/asyncdipatch.nim`.

**Important Limitation**: This implementation is not a complete asynchronous processing system, but rather aims to **improve code readability and convenience**. It does not include full-fledged asynchronous features such as process suspension, IO blocking waits, or resumption of execution.

## 2. Background and Design Policy

### 2.1. Problem Awareness

Calling other canisters in ICP canisters inevitably leads to callback-based descriptions:

```nim
# Traditional way (callback hell)
proc onReply1(env: uint32) {.exportc.} =
  # First reply processing
  callCanister2(args2, onReply2, onReject2)

proc onReply2(env: uint32) {.exportc.} =
  # Second reply processing  
  callCanister3(args3, onReply3, onReject3)

proc onReply3(env: uint32) {.exportc.} =
  # Final processing
  ic0_msg_reply()
```

Such multiple sequential callbacks significantly impair code readability and maintainability.

### 2.2. Solution Policy

The `await` macro allows the above code to be written as follows:

```nim
import asyncwasm/asyncdipatch

# Desired writing style
proc handler() {.update, async.} =
  try:
    let result1 = await callCanister1(args1)
    let result2 = await callCanister2(args2) 
    let result3 = await callCanister3(args3)
    reply(result3)
  except CatchableError as e:
    reject("An error occurred: " & e.msg)
```

The macro automatically generates callback functions, enabling procedural-style descriptions.

### 2.3. Design Goals and Constraints in ICP Environment

This implementation aims to achieve an asynchronous processing model based on Futures and iterators, referencing Nim's standard `async`/`await` mechanism explained in `async_await_in_nim.md`.

However, the ICP WASM environment has unique constraints, so the following points must be considered:

- ❗ **Passive Dispatch Model**: ICP canisters cannot implement an event loop that actively polls OS threads or I/O events. All asynchronous processing must operate on a **passive dispatch model** triggered by messages from the IC (reply callbacks).
- ❗ **`await` suspends execution**: An `await` that calls an external canister means, under the IC's execution model, suspending and ending the current function's execution and instructing the IC to wait for a reply. When a reply is received, the IC system calls the specified callback function to resume processing.

## 3. Implementation Design

### 3.1. Future Type

The `Future[T]` type provided by Nim's standard library `std/asyncfutures` is fully adopted to manage asynchronous operation results, ensuring compatibility with the standard library.

`Future[T]` is a reference object with the following main fields:
*   `value: T`: Holds the result value on success.
*   `finished: bool`: Flag indicating whether the Future has completed (success or failure).
*   `error: ref Exception`: Exception object on failure.
*   `callbacks: seq[proc(future: Future[T])]`: List of callback functions to be called when the Future completes. `await` continuations are registered here.

### 3.2. `async` Macro

Following Nim's standard `std/asyncmacro`, an `async` macro that processes the `{.async.}` pragma is implemented. This macro parses the procedure body (AST) and transforms it into a **closure-iterator** that can suspend and resume processing at `await` keywords.

```nim
# Conversion policy explained in async_await_in_nim.md
macro async(prc: untyped): untyped =
  # Generates code that converts a procedure into a closure-iterator
```

### 3.3. `await` Template Behavior

`await` is implemented as a template that takes `Future[T]` as an argument. Inside an iterator converted by `{.async.}`, `await` expands to a `yield` statement. This suspends the iterator's execution until the specified Future completes.

#### Conversion Example

As shown in `async_await_in_nim.md`, the macro converts seemingly synchronous code into an asynchronously executable iterator.

```nim
# Code written by user
proc example(): Future[string] {.async.} =
  echo "Before call"
  let result = await callOtherCanister("test") # This returns Future[string]
  echo "After call: ", result
  return "done"

# Code generated by async macro (concept)
iterator exampleIter(): FutureBase {.closure.} =
  echo "Before call"
  let future = callOtherCanister("test")
  yield future # Suspend until future completes
  let result = future.read()
  echo "After call: ", result
  # Return final result via a helper that returns a completed Future
  return newCompletedFuture("done") 

proc example(): Future[string] =
  # Helper function that drives the iterator and returns the final Future
  return iterToFuture(exampleIter())
```
This helper function, like `iterToFuture`, is responsible for stepping through the iterator, waiting for `yield`ed Futures to complete, and moving to the next step. This forms the core of the **passive dispatcher** in the ICP environment.

### 3.4. Consistency with Standard Library

The aim is to provide an intuitive API for Nim developers by maintaining compatibility with [Nim's standard `std/asyncmacro`](https://nim-lang.org/docs/asyncmacro.html#18) as much as possible.

## 4. Planned API Implementation

### 4.1. Basic Macros and Templates

```nim
# async macro - converts procedure to async
macro async*(prc: untyped): untyped
template await*[T](f: Future[T]): T
template reject*(message: string)
template reply*[T](value: T)
```

### 4.2. Support Functions

```nim
# Helper for ICP canister calls (returns Future)
proc callCanister*[T](canister_id: Principal, method: string, 
                     args: seq[byte]): Future[T]
```

## 5. Usage Examples

### 5.1. Basic Usage Pattern

```nim
import asyncwasm/asyncdipatch

proc getUserData() {.update, async.} =
  try:
    let userData = await getUserCanister.getUser(userId)
    reply(userData)
  except CatchableError as e:
    reject("Failed to get user data: " & e.msg)
```

### 5.2. Multiple Calls

```nim
proc processOrder() {.update, async.} =
  try:
    let user = await userCanister.getUser(userId)
    let inventory = await inventoryCanister.checkStock(productId)
    
    if inventory.available:
      let order = await orderCanister.createOrder(user, productId)
      reply(order)
    else:
      reject("Out of stock")
  except CatchableError as e:
    reject("Order processing failed: " & e.msg)
```

### 5.3. Error Handling

`try/except` syntax can be used naturally. Exceptions raised in asynchronous operations can be caught by the `await` caller.

```nim
proc robustCall() {.update, async.} =
  try:
    let result = await riskyCanister.process(data)
    reply(result)
  except CatchableError as e:
    reject("Processing failed: " & e.msg)
```

## 6. Limitations

### 6.1. Functional Limitations

- **Passive Execution Only**: Resumption of execution depends on callbacks from IC.
- **Sequential Execution**: `await` executes sequentially. Support for parallel execution (`waitFor all(@[fut1, fut2])`) is a future task.

### 6.2. Syntax Limitations

- **Only within `{.async.}` procedures**: `await` can only be used within procedures transformed by `{.async.}`.

### 6.3. Debugging Limitations

- **Stack Traces**: Stack traces after macro expansion do not correspond to original code.
- **Error Line Numbers**: Identifying the exact line where an error occurred can be difficult.

## 7. Implementation Example: Management Canister Call

### 7.1. Traditional Implementation (Callback Style)

```nim
# Pre-define callback functions
proc onECDSAReply(env: uint32) {.exportc.} =
  let size = ic0_msg_arg_data_size()
  var buf = newSeq[uint8](size)
  ic0_msg_arg_data_copy(ptrToInt(addr buf[0]), 0, size)
  let result = decodeCandid[EcdsaPublicKeyResult](buf)
  reply(result)

proc onECDSAReject(env: uint32) {.exportc.} =
  reject("ECDSA call failed")

proc getPublicKey() {.update.} =
  let args = EcdsaPublicKeyArgs(...)
  callManagementCanister("ecdsa_public_key", encodeCandid(args),
                        onECDSAReply, onECDSAReject)
```

### 7.2. Implementation using `await` Macro

```nim
import asyncwasm/asyncdipatch
import nicp_cdk/canisters/management_canister

proc getPublicKey() {.update, async.} =
  let args = EcdsaPublicKeyArgs(...)
  try:
    # publicKey returns Future[EcdsaPublicKeyResult]
    let result = await asyncManagementCanister.publicKey(args)
    reply(result)
  except CatchableError as e:
    reject("ECDSA call failed: " & e.msg)
```

## 8. Project Structure

### 8.1. File Structure

This implementation is provided with the following file structure:

#### Type, Function, and Pragma Definitions for Asynchronous Processing
**`src/asyncwasm/asyncdipatch.nim`**
```nim
# Basic macro and template definitions (conforming to Nim standard asyncmacro)
macro async*(prc: untyped): untyped
template await*[T](f: Future[T]): T
template reject*(message: string)
template reply*[T](value: T)

# Uses std/asyncfutures
import std/asyncfutures
```

#### Asynchronized External Canister Calls
**`src/nicp_cdk/canisters/management_canister.nim`**
```nim
import std/options
import std/asyncfutures
import ../ic_types/ic_principal
import ../ic_types/candid_types
import ../ic0/ic0
import ../ic_types/candid_message/candid_encode
import ../ic_types/candid_message/candid_decode

type ManagementCanister* = object

proc publicKey*(_:type ManagementCanister, arg: EcdsaPublicKeyArgs): Future[EcdsaPublicKeyResult] =
  # 1. Create a new Future to store the result
  result = newFuture[EcdsaPublicKeyResult]("publicKey")

  # 2. Define a wrapper procedure to complete the Future within the IC callback
  proc onReplyWrapper(env: uint32) {.exportc.} =
    let size = ic0_msg_arg_data_size()
    var buf = newSeq[uint8](size)
    ic0_msg_arg_data_copy(ptrToInt(addr buf[0]), 0, size)
    # Decode Candid message to get the result
    let decoded = decodeCandidMessage(buf) 
    let publicKeyResult = candidValueToEcdsaPublicKeyResult(decoded.values[0])
    
    # Complete the Future on success
    result.complete(publicKeyResult)

  proc onRejectWrapper(env: uint32) {.exportc.} =
    let err_size = ic0_msg_arg_data_size()
    var err_buf = newSeq[uint8](err_size)
    ic0_msg_arg_data_copy(ptrToInt(addr err_buf[0]), 0, err_size)
    let msg = "call failed: " & $err_buf
    # Fail the Future on failure
    result.fail(newException(Defect, msg))

  # 3. IC0 API call processing
  let mgmtPrincipalBytes: seq[uint8] = @[]
  let destPtr = if mgmtPrincipalBytes.len > 0: mgmtPrincipalBytes[0].addr else: nil
  let destLen = mgmtPrincipalBytes.len
  let methodName = "ecdsa_public_key".cstring
  
  ic0_call_new(
    callee_src = cast[int](destPtr),
    callee_size = destLen,
    name_src = cast[int](methodName),
    name_size = methodName.len,
    reply_fun = cast[int](onReplyWrapper),
    reply_env = 0,
    reject_fun = cast[int](onRejectWrapper),
    reject_env = 0
  )

  # ... (Argument attachment and execution)
  let candidValue = newCandidRecord(arg)
  let encoded = encodeCandidMessage(@[candidValue])
  ic0_call_data_append(ptrToInt(addr encoded[0]), encoded.len)
  
  let err = ic0_call_perform()
  if err != 0:
    result.fail(newException(Defect, "call_perform failed with code: " & $err))

let asyncManagementCanister* = ManagementCanister()
```

#### Canister Entry Point
**`examples/async_t_ecdsa/src/async_t_ecdsa_backend/main.nim`**
```nim
import std/options
import std/asyncfutures
import ../../../../src/nicp_cdk
import ../../../../src/nicp_cdk/canisters/management_canister

proc getPublicKey() {.update, async.} =
  let arg = EcdsaPublicKeyArgs(
    canister_id: some(Principal.fromText("be2us-64aaa-aaaaa-qaabq-cai")),
    derivation_path: @[Msg.caller().bytes],
    key_id: EcdsaKeyId(
      curve: EcdsaCurve.secp256k1,
      name: "dfx_test_key"
    )
  )
  try:
    let result = await asyncManagementCanister.publicKey(arg)
    reply(result)
  except CatchableError as e:
    trap("Failed to get public key: " & e.msg)
```

### 8.2. Operation Verification Steps

#### 8.2.1. Deployment

```bash
cd /application/examples/async_t_ecdsa
dfx deploy -y
```

#### 8.2.2. Functional Test

```bash
dfx canister call async_t_ecdsa getPublicKey
```

#### 8.2.3. Expected Output

If successful, an ECDSA public key will be returned:

```
(
  record {
    public_key = blob "\04\XX\XX...";  # Public key byte array
    chain_code = blob "\XX\XX...";     # Chain code
  }
)
```

## 9. Implementation Strategy

### 9.1. Phased Implementation

1. **Phase 1**: Basic `await` macro implementation
2. **Phase 2**: Addition of error handling
3. **Phase 3**: Support for complex control flow

### 9.2. Testing Strategy

- **Unit Tests**: Verification of macro expansion results
- **Integration Tests**: Operational verification with actual canister calls
- **Error Cases**: Confirmation of proper error handling in abnormal scenarios

This design aims to resolve **callback hell** in ICP canister development, enabling more readable and maintainable code similar to Nim's standard asynchronous processing. 