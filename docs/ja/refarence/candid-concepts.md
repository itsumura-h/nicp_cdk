https://github.com/dfinity/candid/blob/master/docs/modules/candid-guide/pages/candid-concepts.adoc

# Candidとは？

Candidはインターフェース記述言語です。その主な目的は、通常インターネットコンピュータ上で動作するカニスタースマートコントラクトとしてデプロイされるプログラムの形式で、サービスの公開インターフェースを記述することです。Candidの重要な利点の1つは、言語に依存しないことであり、Motoko、Rust、JavaScriptを含む異なるプログラミング言語で書かれたサービスとフロントエンド間の相互運用を可能にすることです。

Candidによる典型的なインターフェース記述は、次のようになります。

```
service counter : {
  add : (nat) -> ();
  subtract : (nat) -> ();
  get : () -> (int) query;
  subscribe : (func (int) -> ()) -> ();
}
```

この例では、記述されたサービス「counter」は、以下の公開メソッドで構成されています。

* `add`メソッドと`subtract`メソッドは、カウンターの値を変更します。
* `get`メソッドは、カウンターの現在の値を読み取ります。
* `subscribe`メソッドは、別の関数を呼び出すために使用できます。たとえば、カウンターの値が変更されるたびに通知コールバックメソッドを呼び出すなどです。

この例が示すように、すべてのメソッドは、一連の引数と戻り値の型を持ちます。メソッドには、この例に示されている`query`アノテーションのように、インターネットコンピュータに固有のアノテーションを含めることもできます。

この単純なインターフェース記述があれば、コマンドラインから直接、またはウェブベースのフロントエンドを通じて、あるいはRustプログラムからプログラム的に、または別のプログラミング言語やスクリプト言語を通じて、このカウンターサービスと対話することが可能です。

相互運用性に加えて、Candidは既存のクライアントを壊すことなく行える変更を正確に指定することで、サービスインターフェースの進化をサポートします。たとえば、既存のクライアントとの互換性を維持したまま、新しいオプションのパラメータをサービスに安全に追加できます。

## なぜ新しいIDLを作成するのか？

一見すると、JSON、XML、Protobufなどの他の技術で十分ではないかと思われるかもしれません。しかし、Candidは、これらの他の技術には見られない独自の機能の組み合わせを提供します。Candidがインターネットコンピュータ向けのdapps開発に特に適している機能には、以下が含まれます。

* JSON、XML、Protobufなどの多くの言語は、個々の値をバイトまたは文字にマッピングする方法のみを記述します。これらのデータ記述言語は、サービス全体を記述しません。これらの言語は、メソッドが利用するデータ型ではなく、転送したいデータ型に焦点を当てています。

* Candidの実装は、Candidの値をホスト言語の型と値に直接マッピングします。Candidを使用すると、開発者は抽象的なCandidの値を構築したり分解したりしません。

* Candidは、サービスとそのインターフェースを健全かつ合成的な方法でアップグレードする方法に関するルールを定義します。

* Candidは本質的に高階言語です。Candidを使用すると、プレーンなデータだけでなく、サービスやメソッドへの参照など、より多くのものを渡すことができます。Candidの安全なアップグレードのサポートは、このような高階の使用を考慮に入れています。

* Candidは、`query`アノテーションなど、特定のインターネットコンピュータの機能を組み込みでサポートしています。

## Candidの型と値

Candidは、ほとんどの用途を網羅する一連の型を持つ、強い型付けのシステムです。それは以下を含みます。

* 非境界整数型 (`nat`, `int`)
* 境界整数型 (`nat8`, `nat16`, `nat32`, `nat64`, `int8`, `int16`, `int32`, `int64`)
* 浮動小数点型 (`float32`, `float64`)
* ブール型 (`bool`)
* テキストデータ (`text`) およびバイナリデータ (`blob`) の型
* バリアント (`opt`, `vec`, `record`, `variant`) を含むコンテナ型
* 参照型 (`service`, `func`, `principal`)
* 特殊なnull型、予約型、空型

すべての型は、[リファレンス](https://github.com/dfinity/candid/blob/master/docs/modules/candid-guide/pages/candid-ref.adoc)セクションで詳細に説明されています。

この型セットの背後にある哲学は、データの構造を記述するのに十分であり、情報がエンコード、受け渡し、デコードできる一方で、表現を記述するのに必要な範囲を超えた意味的制約は意図的に記述しないということです。たとえば、数値が偶数であること、ベクトルの長さが特定の値であること、またはベクトルの要素がソートされていることを表現する方法はありません。

Candidは、Motoko、Rust、JavaScript、またはその他の言語でコードを書いているかどうかにかかわらず、各ホスト言語に適した合理的で標準的な選択に基づいてデータ型を自然にマッピングできるように、この型セットをサポートしています。

## Candidサービス記述

Candidの型に慣れたら、それらを使用してサービスを記述できます。Candidサービス記述ファイル（.DIDファイル）は、手動で作成することも、サービス実装から生成することもできます。

特定のホスト言語のサービス記述を生成する方法を探る前に、サンプルサービス記述の構造と構成要素を詳しく見てみましょう。

最も単純なサービス記述は、公開メソッドを持たないサービスを指定するもので、次のようになります。

```
service : {}
```

このサービスはあまり役に立ちません。そこで、簡単な`ping`メソッドを追加してみましょう。

```
service : {
  ping : () -> ();
}
```

この例では、`ping`という単一の公開メソッドをサポートするサービスを記述しています。メソッド名は任意の文字列にすることができ、プレーンな識別子でない場合は引用符で囲むことができます（例: `"スペースを含むメソッド"`）。

メソッドは、引数と戻り値の型のシーケンスを宣言します。この`ping`メソッドの場合、引数も戻り値も渡されないため、引数と戻り値の両方に空のシーケンス`()`が使用されています。

最も単純なケースを見たので、もう少し複雑なサービス記述を考えてみましょう。このサービスは、`reverse`と`divMod`の2つのメソッドで構成されており、各メソッドには引数と戻り値の型のシーケンスが含まれています。

```
service : {
  reverse : (text) -> (text);
  divMod : (dividend : nat, divisor : nat) -> (div : nat, mod : nat);
}
```

`reverse`メソッドは、`text`型の単一のパラメータを受け取り、`text`型の1つの値を返します。

`divMod`メソッドは、どちらも`nat`型の2つの値を受け取り、2つの値を返します。

## 引数と結果の命名

前の例では、`divMod`メソッドのシグネチャに、引数と結果の値の名前が含まれています。メソッドの引数または結果に名前を付けることは、純粋にドキュメント化のためです。使用する名前は、メソッドの型や渡される値を変更しません。代わりに、引数と結果は名前とは無関係に、その位置によって識別されます。

特に、Candidは、型を次のように変更することを妨げません。

```
divMod : (dividend : nat, divisor : nat) -> (mod : nat, div : nat);
```

または、最初に`mod`を返すメソッドを期待するサービスに上記の`divMod`を渡すことも可能です。

したがって、これは意味的に重要な名前付きレコードフィールドとは大きく異なります。

## 複雑な型の再利用

多くの場合、サービス内の複数のメソッドが同じ複雑な型を参照することがあります。その場合、型に名前を付けて複数回再利用できます。例：

```
type address = record {
  street : text;
  city : text;
  zip_code : nat;
  country : text;
};
service address_book : {
  set_address: (name : text, addr : address) -> ();
  get_address: (name : text) -> (opt address) query;
}
```

これらの型定義は、既存の型を単に省略するだけであり、新しい型を定義するものではありません。関数シグネチャで`address`を使用しても、レコードを直接記述しても違いはありません。また、異なる名前を持つが同等の定義を持つ2つの省略形は、同じ型を表し、互換性があります。言い換えれば、Candidは構造的部分型付けを使用します。

## クエリメソッドの指定

最後の例では、`get_address`メソッドに`query`アノテーションが使用されていることに気付いたかもしれません。例：

```
service address_book : {
  set_address: (name : text, addr : address) -> ();
  get_address: (name : text) -> (opt address) query;
}
```

このアノテーションは、`get_address`メソッドが{IC}クエリ呼び出しとして呼び出すことができることを示します。「[クエリメソッドと更新メソッド](https://www.google.com/search?q=https://internetcomputer.org/docs/current/motoko/main/actors-classes/async-methods%23query-methods-and-update-methods)」で説明されているように、クエリはコンセンサスを経由せずにカニスタースマートコントラクトから効率的に情報を取得する方法を提供するため、メソッドをクエリとして識別できることは、{IC}と対話するためにCandidを使用する主な利点の1つです。

## エンコードとデコード

Candidの目的は、サービスメソッドのシームレスな呼び出しを可能にし、バイナリ形式にエンコードされ、基盤となる転送方法（インターネットコンピュータ内外のメッセージなど）によって転送される引数を渡し、反対側でデコードすることです。

Candidのユーザーとして、このバイナリ形式の詳細について心配する必要はありません。Candidを自分で実装する予定がある場合（たとえば、新しいホスト言語をサポートするため）、詳細については[Candid仕様](https://github.com/dfinity/candid)を参照してください。ただし、形式のいくつかの側面は知っておく価値があります。

  * Candidバイナリ形式は、`DIDL…`（または16進数で`4449444c…`）で始まります。低レベルのログ出力でこれを見かけた場合、Candidエンコードされた値である可能性が非常に高いです。

  * Candidバイナリ形式は常に値のシーケンスをエンコードします。これは、メソッドのパラメータと結果が型のシーケンスであるためです。

  * バイナリ形式は非常にコンパクトです。125,000個のエントリを持つ(`vec nat64`)は、1,000,007バイトになります。

  * バイナリは自己記述型であり、そこに含まれる値の型に関する（圧縮された）型記述が含まれています。これにより、受信側は、異なる互換性のない型としてメッセージが送信されたかどうかを検出できます。

  * 送信側が引数を、受信側が期待する型としてシリアライズする限り、デシリアライズは成功します。

## サービスのアップグレード

サービスは時間とともに進化します。新しいメソッドが追加されたり、既存のメソッドがより多くのデータを返したり、追加の引数を期待するようになったりします。通常、開発者は既存のクライアントを壊すことなくこれを行いたいと考えます。

Candidは、新しいサービス型が以前のインターフェース記述を使用しているすべての他の関係者と引き続き通信できるタイミングを示す正確なルールを定義することで、このような進化をサポートします。その基礎となる形式主義は、部分型付けの概念です。

サービスは、以下の方法で安全に進化できます。

* 新しいメソッドを追加できます。

* 既存のメソッドは、追加の値を返すことができます。つまり、戻り値の型のシーケンスを拡張できます。古いクライアントは、追加の値を単に無視します。

* 既存のメソッドは、パラメータリストを短縮できます。古いクライアントは追加の引数を送信する可能性がありますが、それらは無視されます。

* 既存のメソッドは、オプションの引数（型 `opt` ...）でパラメータリストを拡張できます。その引数を渡さない古いクライアントからのメッセージを読み取る場合、`null`値が想定されます。

* 既存のパラメータ型は変更できますが、以前の型のスーパータイプにのみ変更できます。

* 既存の戻り値の型は変更できますが、以前の型のサブタイプにのみ変更できます。

特定の型のスーパータイプとサブタイプに関する情報については、その型の対応する[リファレンス](https://github.com/dfinity/candid/blob/master/docs/modules/candid-guide/pages/candid-ref.adoc)セクションを参照してください。

サービスの進化の具体的な例を見てみましょう。次のAPIを持つサービスを考えます。

```
service counter : {
  add : (nat) -> ();
  subtract : (nat) -> ();
  get : () -> (int) query;
  subscribe : (func (int) -> ()) -> ();
}
```

このサービスは、次のインターフェースに進化できます。

```
type timestamp = nat;
service counter : {
  set : (nat) -> ();
  add : (int) -> (new_val : nat);
  subtract : (nat, trap_on_underflow : opt bool) -> (new_val : nat);
  get : () -> (nat, last_change : timestamp) query;
  subscribe : (func (nat) -> (unregister : opt bool)) -> ();
}
```

## Candidのテキスト形式の値

Candidの主な目的は、例えばMotoko、Rust、JavaScriptなどのホスト言語で書かれたプログラムを{IC}に接続することです。したがって、ほとんどの場合、プログラムのデータをCandidの値として扱う必要はありません。代わりに、使い慣れたJavaScriptの値を使用してJavaScriptのようなホスト言語で作業し、Candidにそれらの値をRustやMotokoで書かれたカニスタースマートコントラクトに透過的に転送させます。値を受け取ったカニスターは、それらをネイティブなRustまたはMotokoの値として扱います。

ただし、ログ記録、デバッグ、コマンドラインでのサービスとの対話など、Candidの値を人間が読める形式で直接確認できると便利な場合があります。このようなシナリオでは、Candidの値のテキスト表現を使用できます。

構文はCandidの型の構文と似ています。たとえば、Candidの値の典型的なテキスト表現は次のようになります。

```
(record {
  first_name = "John";
  last_name = "Doe";
  age = 14;
  membership_status = variant { active };
  email_addresses =
    vec { "john@doe.com"; "john.doe@example.com" };
})
```

> Candidのバイナリ形式には、実際のフィールド名は含まれておらず、数値ハッシュのみが含まれています。したがって、期待される型に関する知識なしにこのような値を整形出力すると、レコードとバリアントのフィールド名は含まれません。上記の値は、次のように出力される可能性があります。

```
(record {
   4846783 = 14;
   456245371 = variant {373703110};
   1443915007 = vec {"john@doe.com"; "john.doe@example.com"};
   2797692922 = "John"; 3046132756 = "Doe"
})
```

## サービス記述の生成

[上記のセクション](https://github.com/dfinity/candid/blob/master/docs/modules/candid-guide/pages/candid-concepts.adoc#candid-service-descriptions)では、Candidのサービス記述を最初から作成する方法を学びました。しかし、多くの場合、それさえ必要ありません！サービスの実装に使用する言語によっては、コードからCandidサービス記述を生成できます。

たとえば、Motokoでは、次のようなカニスタースマートコントラクトを作成できます。

```
actor {
  var v : Int = 0;
  public func add(d : Nat) : async () { v += d; };
  public func subtract(d : Nat) : async () { v -= d; };
  public query func get() : async Int { v };
  public func subscribe(handler : func (Int) -> async ()) { … }
}
```

このプログラムをコンパイルすると、{proglang}コンパイラは、上記のインターフェースを持つCandidサービス記述ファイルを自動的に生成します。

RustやCなどの他の言語では、ネイティブなRustの型など、その言語にネイティブな型を使用してサービスを開発できます。ただし、Rustのような言語でサービスを開発した後、現在、Candidでサービス記述を自動的に生成する方法はありません。したがって、RustまたはCでサービスのプログラムを作成する場合は、[Candid仕様](https://github.com/dfinity/candid)で説明されている規約に従って、Candidインターフェース記述を手動で作成する必要があります。

RustプログラムのCandidサービス記述の作成方法の例については、[Rust CDKの例](https://github.com/dfinity/cdk-rs/tree/next/examples)および[Rustチュートリアル](https://github.com/dfinity/candid/blob/master/docs/modules/candid-guide/rust-guide/rust-intro.adoc)を参照してください。

使用するホスト言語に関係なく、ホスト言語の型とCandidの型とのマッピングを知っておくことが重要です。「サポートされている型」のリファレンスセクションでは、Motoko、Rust、JavaScriptについて説明されているCandidの型マッピングを見つけることができます。
