# NimのAsync/Await: メタプログラミングの柔軟性の実証

皆さん、こんにちは。本日の最後の講演にお越しいただき、ありがとうございます。家に帰りたくてうずうずしていることでしょう。私の名前はドミニク・ピハタです。長年Nimのコアコントリビューターを務めており、「Nim in Action」というNimに関する最初の本を執筆しました。現在は、昼間はFacebookで働き、夜は時間がある限りNimに取り組んでいます。

早速、本題のNimのasync/awaitについてお話ししましょう。

## Nim入門

ここにいる多くの方はこれを聞く必要はないかもしれませんし、すでにNimについて聞いたことがある方もいるでしょう。しかし、Nimに馴染みのない方や、ご自宅でご覧になっている方のために、いくつか紹介の言葉を述べたいと思います。

Nimとは何か？もちろん、Nimはプログラミング言語ですが、非常に特殊な特徴をいくつか持っています。

*   **効率的でポータブル:** C、C++、Objective-C、さらにはJavaScriptにもコンパイルできます。これにより、Cの速度に匹敵し、Cの広範なライブラリにアクセスできます。
*   **習得が容易:** Nimは、優れたマクロシステムを使用してより多くの機能を実装し、小さな言語コアを構築することに重点を置いています。これにより、誰でも簡単に習得できます。
*   **モダン:** ジェネリクス、イテレータ、クロージャ、優れたモジュールシステムなど、現代の言語に期待される多くの機能が含まれています。
*   **本番環境に対応:** 昨年1.0リリースを迎え、Nimは後方互換性を保証し、本番環境での使用に対応できるようになりました。1.0リリースの素晴らしい点は、手続きマクロとasync/awaitという2つの非常に素晴らしい機能が搭載されたことです。この講演ではその両方に触れます。

さて、前置きはこれくらいにして、本題に移りましょう。まずはいくつかの基本事項からです。

## I/Oの問題点

I/Oの問題とは何でしょうか？ハードドライブからのデータ読み取りやネットワーク経由での情報受信などのI/O操作は、非常に遅くなる可能性があります。同期I/Oを実行すると、I/O操作の進行中にアプリケーションが有用な作業を行わなくなり、アプリケーションがブロックされてしまいます。

一方、非同期I/Oは、I/O操作が完了したかどうかを繰り返し確認できるメカニズムを提供することで、この問題を解決します。しかし、これを簡単な方法で行う方法はありません。各操作が完了したときに実行されるべき多くのアクションを伴う何千ものI/O操作をどのように管理すればよいのでしょうか？

最も基本的な解決策はコールバックを使用することです。しかし、ご存知の方も多いと思いますが、コールバックは管理が非常に難しくなります。これがNimでのコールバックの例です。主な理由は、コールバックがうまく構成されないことです。理想的には、非I/Oコードを記述するのと同じようにI/Oコードを記述したいのです。

```nim
proc onGotSecoundaryData(data: string) =
  echo "Got: ", data

proc onGotFirstData(data: string) =
  socket.recv(100, onData=onGotSecoundaryData)

proc getData(socket: AsyncSocket) =
  socket.recv(100, onData=onGotFirstData)
```

このコードを説明すると、基本的には3つの関数です。下部にある `getData` は、ソケットから100バイトのデータを読み取り、`onGotFirstData` というコールバックを受け取り、さらに100バイトを読み取り、別のコールバックを受け取り、最終的にそのコールバックが受信コールからの結果を出力します。

コールバックは最悪です。これには皆さん同意してくれると思います。

## より良い解決策: Async/Await

最良の解決策の1つは、私たちがasync/awaitと呼ぶものだと思います。これは、まさにそれを示す別の例です。ソケットと非同期ソケットを受け取る `getData` 手続きがあります。そこにある `async` プラグマは、それが非同期手続きであることを示しています。ソケットから読み取った最初の100バイトは破棄され、2番目の100バイトのみを使用してそれを出力することがすぐにわかります。コードははるかに理解しやすく、`await` コールはどこでI/Oが実行されているかについての有用なヒントを提供します。

```nim
proc getData(socket: AsyncSocket): {.async.} =
  discard await socket.recv(100)
  let secoundData = await socket.recv(100)
  echo "Got: ", secoundData
```

さて、C#やRustのような他の言語でこれを見たことがあるかもしれませんが、これには特別な点があります。それは、Nimでは完全にマクロを使用して実装されているということです。コンパイラにはこれに対するサポートがまったくありません。これから、これについて詳しく説明します。

## NimのAsyncの構成要素

まず、Nimのasyncのすべてのコンポーネントがどのように連携しているかを見ていきましょう。実際にはそれほど多くはなく、4つのコンポーネントがあります。

1.  Future
2.  非同期手続き
3.  `selectors`モジュール
4.  非同期ディスパッチャ

これらをもう少し詳しく見ていきましょう。

### Future

`Future` は、コンテナとして機能する単純なオブジェクトです。上部のコードを実行すると、ジェネリック型 `T` を受け取る単純なジェネリック型定義であることがわかります。4つのフィールドがあります。
*   `value`: futureに格納される値を格納します。
*   `callback`: futureが完了したときに呼び出されるプロシージャを設定できます。
*   `finished`: futureが完了したかどうかを追跡するためのフィールド。
*   `exception`: futureの計算中にエラーが発生した場合のためのものです。

```nim
type Future[T] = ref object
  value: T
  callback: proc()
  finished: bool
  exception: Exception
```

### 非同期手続き

```nim
proc findPageSize(client: AsyncHttpClient, url: Uri):Future[int] {.async.} =
  let data = await client.getContent(url)
  return data.len
```

これは `findPageSize` という非同期手続きの別の例です。`AsyncHttpClient` と `url` の2つの引数を取り、`Future[int]` を返します。その後に、非同期手続きであることを示す `async` プラグマが再び表示されます。ボディでは、HTTPクライアントを使用してURLにHTTP GETを送信し、受信したデータの長さを返します。

ここで問題となるのは、Nimは非同期手続きの仕組みを全く知らないため、`async` プラグマなしでこれをどのように表現するかということです。

```nim
proc findPageSize(client: AsyncHttpClient, url: Uri):Future[int] =
  result = newFuture[int]()
  let dataFut = client.getContent(url)
  dataFut.callback = proc() =
    result.complete(dataFut.read().len)
```

1つの可能な方法は、コールバックを使用するように変換することです。このようになります。関数は非常によく似ていますが、`async` プラグマはもうありません。`result` が新しく割り当てられた `Future` に設定され、次に `getContent` 手続きを再度呼び出します。これによりfutureが返されます。それを新しい変数に割り当て、そのコールバックフィールドに新しい手続きを割り当て、そのコールバックで、データfutureの長さで結果のfutureを完了させます。ここでは多くのfutureが登場しますが、ご理解いただけると幸いです。

これは理想的ではありません。問題は、スケーラブルではないことです。同期手続きに制御フローを追加するとすぐに問題が発生します。変換は非常に困難になります。

Andreasから聞いたことを前置きとしてお話しなければなりませんが、どうやらこれを達成することは可能だということですが、調べてみても、これを行っているプログラミング言語は見つかりませんでした。JavaScriptでさえ、Babelを使用して `await` を含むJavaScriptコードをECMAScript 5に変換する場合でも、イテレータを使用します。

これにより、2番目の変換試行であるイテレータの使用に至ります。ここでも非常によく似たコードがありますが、イテレータを使用しているだけです。Nimでは基本的にイテレータをヒープに割り当て可能なものに変える `closure` プラグマがあります。これにより、各 `await` ステートメントを `yield` に変更するだけで済むため、変換がはるかに簡単になります。残りの部分は前のコードとかなり似ていますが、より複雑な例を変換するのがそれほど難しくないことがわかると思います。スケーラビリティの問題は解決されます。

```nim
proc findPageSize(client: AsyncHttpClient, url: Uri):Future[int] {.closure.} =
  result = newFuture[int]()
  let dataFut = client.getContent(url)
  yield dataFut
  result.complete(dataFut.read().len)
```

## Nimでのメタプログラミング
次に、Nimでのメタプログラミングに移ります。この変換をどのように実現するかをお見せします。

```nim
proc testAsync(): Future[int] {.async.} =
  return await getMagicInt()

macro async(body: untyped): untyped =
  echo treeRepr(body)
```

さて、この単純な手続きがあります。この例のために、少し単純化する必要があると思います。Nimでマクロの開発を始めるとき、通常はこのようなものから始めます。`untyped` 型の `body` パラメータを取る `async` マクロです。これは、複数のコードステートメントを参照する魔法のような型であり、プロシージャコードステートメントを別のコードステートメントに変換しているため、`untyped` を返します。その本体では、抽象構文木（AST）のツリー表現を表示しているだけです。

そして、このようになります。下部には、Nimプレイグラウンドで試してみたい場合のリンクがあります。ブラウザで実行できます。基本的には、手続きの各コンポーネント（名前 `testAsync`、パラメータ（この場合は戻り値のみ）、`await` と `return` ステートメントを含むボディ）を持つ、この素晴らしいツリー構造が得られます。

例に戻り、同期手続きを同等のイテレータに変換するマクロをどのように開発するのでしょうか？まあ、こんな感じです。すべての非同期手続きに対して汎用的に機能するものを示すことはできなかったので、ここでは明らかにいくつかの自由を利かせました。スライドには収まりません。

```nim
proc testAsync(): Future[int] {.async.} =
  return await getMagicInt()

macro async(body: untyped): untyped =
  let name = body[0]
  let returnType = body[3][0]
  let awaitedFunc = body[6][0][0][1]
  result = quote:
    iterator `name`(): `returnType` =
      yield `awaitedFunc`
  echo result.toStrLit
```

そこで、ここでは、変換している各ノードのAST内の場所をハードコーディングします。ボディの最初の子ノードを取得し、それを手続きの名前である `name` 変数に割り当てます。次に、戻り値の型を取得します。そして、待機される関数は、ボディからそれを取得し、1つしかないと仮定します。明らかに、これはすぐに壊れてしまいます。

そして、Nimのこの素晴らしい機能を使用して、マクロで出力したいものを基本的にクォートします。バッククォートを使用して、必要なASTノードを埋め込みます。それが結果になります。次に、マクロの結果、返しているASTノードをNimコードの形式で表示します。繰り返しになりますが、そこの下部にあるリンクを使用してこれを試すことができます。そして、このコードを実行すると、コンソールにそれが表示されます。これがマクロの結果です。

```nim
iterator testAsync(): Future[int] =
  yield getMagicInt()
```

これでメタプログラミングは終わりです。これがどのように機能するかの少しのアイデアを与え、さらに詳しく調べるきっかけになることを願っています。

## その他の構成要素

他のいくつかのコンポーネントをざっと見ていきましょう。

### `selectors`モジュール

標準ライブラリにある `selectors` モジュールは、準備完了ベースのI/O APIを実装しています。基本的には `epoll`、`kqueue` などをラップし、優れたAPIを提供します。依存関係がなく、高性能で、基本的にすべてをサポートしているため、非常にポータブルです。

### 非同期ディスパッチャ

また、`selectors` 上に構築された非同期ディスパッチャもあり、proactor APIを実装しています。したがって、システムに「ソケットから読み取りたいのですが、読み取れますか？」と尋ねる代わりに、「ソケットから100バイトのデータを読み取りたい」と言うと、それが準備できたときに通知されます。これは、実際にはWindowsのI/O完了ポートで機能する方法です。したがって、このモジュールはWindowsにI/O完了ポートも実装し、proactor APIを提供するために `selectors` モジュールの上にレイヤーを提供します。

## NimのAsyncの現状と将来

さて、手短に、Nimのasyncの現状です。本番環境で使用されています。Nimフォーラムはそれで動作しています。また、TechEmpowerベンチマークでかなり良い数値を獲得しているこのHTTPサーバーもあります。Rustと肩を並べています。`httpbeast` と呼ばれていますので、興味があれば見てみてください。

そして、asyncの将来：Rustからいくつかのアイデアを借用し、ポーリングfutureを使用してゼロコスト抽象化を使用するかもしれません。Nimの並列処理とのより良い統合（現在 `spawn` と `await spawn` を使用する方法はありません）、そしてより良いスタックトレースも同様です。

学ぶための最良の方法は、私の本を手に取ることです。以上です。他にもいくつかリンクがあります。

## Q&A

**質問:** なぜグリーンスレッドを使用しないのですか？

**回答:** それは良い質問です。Nimのようなシステムプログラミング言語では、それははるかに複雑になっていたと思います。グリーンスレッドがある場合、それらを使用するにはランタイムも必要になると想定しますが、これを使用すると、本当に必要ない場合は使用しないことを選択できます。それが主な理由です。

**質問:** それともコールバックを使用しますか？コールバックがある場合、わかりませんが、コールバックは何度でも呼び出すことができます。そのコードを保持する必要がありますか？

**回答:** どういう意味か完全にはわかりません。Nimでの現在の仕組みでは、各futureが基本的にコールバックをエミュレートできます。すべての同期手続きからfutureを返しているので、「このfutureにコールバックを割り当て、準備ができたら呼び出す」と言うことができます。それがその方法です。ソケットから読み取るたびに、新しいfutureを取得し、それに繰り返しコールバックを割り当てます。意味がわかりますか？

さて、これで終わりです。素晴らしい講演をありがとうございました。部屋を出るときは、周りを見回して忘れ物がないか確認してください... [講演終了] 
