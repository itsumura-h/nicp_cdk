https://github.com/dfinity/candid/blob/master/spec/Candid.md

## 動機

インターネットコンピュータ上の_カニスター_（_サービス_または_アクター_とも呼ばれます）を文書化、発見、および操作するには、カニスターのシグネチャを指定するためのインターフェース記述言語（IDL）が必要です。

#### 目標：

* カニスターインターフェースとそれらが交換するデータ（サービスメソッドの名前、パラメータ、および結果の形式）の言語に依存しない記述
* シンプルで標準的な構成要素（C言語に類似；代数的には：直和、直積、冪）
* 拡張可能、後方互換性がある
* 整形式性はプラットフォームによってチェックおよび保証される
* 人間可読かつ機械可読である
* 宣言的であり、バインディングコードジェネレータへの入力として使用可能

#### 非目標：

* 表現に関する懸念を超えた意味的制約の仕様
  （理由：（1）表現すべきものの自然な境界がなく、スケーラブルなソリューションはすぐにプログラム論理や依存型の領域につながるでしょう。（2）プラットフォームのコストと複雑さ、ハイパーバイザーはすべてのメッセージ送信時にこれらのプロパティをチェックして保証する必要があります。（3）一般に、興味深いプロパティは、カニスターの状態などのコンテキスト情報なしには定式化またはチェックできません。）
* ネットワークが内部でデータを転送するために使用するワイヤ形式の規定（ただし、記述されているシリアライズ形式の拡張を使用することは理にかなっています。これはかなり汎用的です。）

#### インスピレーション：

* Protocol buffers
* Thrift
* Fuchsia IDL
* CORBA
* JSON, YAML
* ...
* Fisher, Mandelbaum, Walker: The next 700 data description languages

#### なぜProtocol Buffersなどではないのか？

標準のProtocol Buffersは、インターネットコンピュータ上のカニスターを記述するには不十分であるか、適切ではありません。

* それらは主に*データ記述言語*であり、IDLではありません。「サービス」を定義するための構文はありますが、メッセージングではなくRPCを前提としており、セマンティクスを提供するには（gRPC、別名Stubbyを置き換える）プラグインを開発する必要があります。

* それらはデータを抽象的なprotobufオブジェクトにデシリアライズし、実際の言語データ構造にはデシリアライズしません。「メッセージ」（オブジェクト/レコード/構造体）形式は、独自の抽象的なインメモリ型として表現されるように設計されています。

* それらは本質的に一階のデータ形式であり、メソッドを持つ関数/コールバックやオブジェクト/アクターのパラメータを記述できません。

* それらは、適切な配列、多倍長整数、バリアント、参照など、私たちが処理したいさまざまなデータ型を欠いています。

* それらは、「読み取り専用」またはアクセス制御仕様など、IDL記述に組み込む必要のある他の情報を表現する場所を提供しません。

* それらは、安全なアップグレード可能性を定義するための意味的に健全で合成的な基礎（たとえば、インターフェース型間の関係として）を持っていません。

* それらは、私たちが必要としない、または異なる方法で定義したい可能性のある多くの機能を持っています。

上記のすべてを考慮すると、既存のprotobufバインディングから再利用できるものはほとんどないと思われます。同時に、必要なさまざまな拡張機能を組み込む簡単な方法もないでしょう。

## 型構造

IDLの目的は、アクター（サービス）のシグネチャ、ひいてはその*型*、つまりメッセージの集合とそのパラメータと結果の型を定義することです。そのために、Candidの文法は主に型文法で構成されています。

#### コア文法

提案されている文法の概要は次のとおりです。

```
<prog>  ::= <def>;* <actor>?
<def>   ::= type <id> = <datatype> | import service? <text>
<actor> ::= service <id>? : (<tuptype> ->)? (<actortype> | <id>) ;?

<actortype> ::= { <methtype>;* }
<methtype>  ::= <name> : (<functype> | <id>)
<functype>  ::= <tuptype> -> <tuptype> <funcann>*
<funcann>   ::= oneway | query | composite_query
<tuptype>   ::= ( <argtype>,* )
<argtype>   ::= <datatype>
<fieldtype> ::= <nat> : <datatype>
<datatype>  ::= <id> | <primtype> | <comptype>
<comptype>  ::= <constype> | <reftype>

<primtype>  ::=
  | <numtype>
  | bool
  | text
  | null
  | reserved
  | empty
  | principal

<numtype>  ::=
  | nat | nat8 | nat16 | nat32 | nat64
  | int | int8 | int16 | int32 | int64
  | float32 | float64

<constype>  ::=
  | opt <datatype>
  | vec <datatype>
  | record { <fieldtype>;* }
  | variant { <fieldtype>;* }

<reftype>  ::=
  | func <functype>
  | service <actortype>

<name> ::= <id> | <text>
```

`<id>`、`<nat>`、`<text>`の定義については[下記](https://www.google.com/search?q=%23values)を参照してください。

#### 構文糖衣

この基本文法に加えて、基本形式に還元できるいくつかの構文糖衣がサポートされています。

```
<argtype>  ::= ...
  | <name> : <datatype>    := <datatype>

<constype> ::= ...
  | blob                   :=  vec nat8

<fieldtype> ::= ...
  | <name> : <datatype>    :=  <hash(name)> : <datatype>
  | <datatype>             :=  N : <datatype>  where N is either 0 or previous + 1  (レコード内のみ)
  | <nat>                  :=  <nat> : null   (バリアント内のみ)
  | <name>                 :=  <name> : null  (バリアント内のみ)
```

#### コメント

コメントは、単一行形式またはブロック形式で記述できます。

```
<comment> ::=
  | //<codepoint>*<nl>
  | /*(<codepoint>|<comment>)*/
```

ブロックコメントは（C言語とは異なり）適切にネストされます。

### サービス

*サービス*は、プラットフォーム上のスタンドアロンのアクターであり、*メッセージ*を送受信することで他のサービスと通信できます。メッセージは、サービスの提供する関数である*メソッド*の1つを呼び出すことによってサービスに送信されます。

メインサービスには、サービスコンストラクタ（または未初期化サービス）と実行中のサービス（または初期化済みサービス）の2種類があります。サービスコンストラクタは、プラットフォームにサービスをインストールするための*初期化パラメータ*を受け取ります。初期化されると、サービスは実行中のサービスになります。1つのサービスコンストラクタを複数の実行中のサービスに初期化できます。

**注：** Candidは、サービスの正確な性質に実際には依存しません。特に、サービスが非同期（双方向メッセージ送信を行うアクター）ではなく同期（RPCを持つオブジェクト）である設定にも適用できます。

#### 構造

サービスのシグネチャは*アクター型*によって記述され、サービスが提供する*メソッド*のリストを定義します。各メソッドは、その*名前*と、そのシグネチャを記述する*関数型*によって記述されます。関数型は、関数参照型に名前を付ける型定義を参照することによっても指定できます。

```
<actortype> ::= { <methtype>;* }
<methtype>  ::= <name> : (<functype> | <id>)
```

アクター型における`<methtype>`リストは、順序の変更を無視して識別されます。

#### 名前

名前は、一般的なプログラミング言語の識別子の構文、または引用符で囲まれた任意の文字列として指定できます。

```
<name> ::= <id> | <text>
<id>   ::= (A..Z|a..z|_)(A..Z|a..z|_|0..9)*
<text> ::= "<char>*"
```

識別子は、Candid文法のキーワードであってはなりません。キーワードと一致する名前が必要な場合は、テキスト文字列として引用符で囲む必要があります。

#### 例

```
service : {
  addUser : (name : text, age : nat8) -> (id : nat64);
  userName : (id : nat64) -> (text) query;
  userAge : (id : nat64) -> (nat8) query;
  deleteUser : (id : nat64) -> () oneway;
}
```

### 関数

*関数*は、通信のエンドポイントです。典型的な関数呼び出しは、*パラメータ*と*結果*、別名リクエストとレスポンスを伴う双方向通信です。`oneway`関数呼び出しは、0個以上のパラメータを持ちますが結果を持たない一方向通信であり、fire-and-forgetのシナリオを意図しています。

**注：** Candidは、関数による通信が同期（RPCなど）であるか非同期（応答継続としてのコールバックを伴うメッセージングなど）であるかという問題に実際には依存しません。ただし、すべての呼び出しが同じセマンティクスを持つ、つまり両者を区別する必要がないと想定しています。

**注：** 関数の同期的な解釈では、`oneway`関数の呼び出しは、関数に対するサービス側の呼び出しの完了を待たずに直ちに返ります。関数の非同期的な解釈では、`oneway`関数の呼び出しは（完了時に呼び出す）コールバックを受け入れません。

#### 構造

関数型は、パラメータと結果のリスト、およびそれぞれの型を記述します。オプションで、*query*、*composite_query*、または*oneway*として注釈を付けることができます。

* `query`は、関数が状態を変更せず、より効率的に（例えば、キャッシュされた状態に対して）実行できる可能性があることを示します。
* `composite_query`は、IC固有の機能と制限を持つ特別な`query`関数です。
  - `composite_query`関数は、他の`composite_query`関数と`query`関数のみを呼び出すことができます。
  - `composite_query`関数は、他の`composite_query`関数（`query`または`update`関数からは呼び出し不可）とICの外部からのみ呼び出すことができます。したがって、`query`は`composite_query`のサブタイプではありません。
  - `composite_query`は、サブネットを跨ぐことはできません。
  - これらの制限はすべて実装上の理由による一時的なものです。将来的には、`query`関数と`composite_query`関数は同じものになる予定です。
* `oneway`関数は戻り結果を持たず、呼び出し元は関数の戻りを待つ必要がありません。
* 他の注釈は将来追加される可能性があります。

```
<functype> ::= ( <argtype>,* ) -> ( <argtype>,* ) <funcann>*
<funcann>  ::= oneway | query | composite_query
<argtype>  ::= <datatype>
```

関数型における`<funcann>`リストは、順序の変更を無視して識別されます。

パラメータのリストは2^32個未満でなければなりません。同じ制限が結果リストにも適用されます。`oneway`関数の結果リストは空でなければなりません。

##### 省略記法：名前付きパラメータと結果

「省略記法」として、関数型のパラメータと結果の型には名前をプレフィックスとして付けることができます。

```
<argtype> ::= <name> : <datatype>   := <datatype>
```

選択された名前はドキュメントの目的のみを果たし、意味的な重要性はありません。ただし、重複する名前は許可されません。

#### 例

```
(text, text, nat16) -> (text, nat64)
(name : text, address : text, nat16) -> (text, id : nat64)
(name : text, address : text, nr : nat16) -> (nick : text, id : nat64)
```

これら3つの型はすべて同等です。

### データ

メッセージの引数と結果の内容は*データ*です。*データ型*には、基本的な値である*プリミティブデータ*、データ型の複合形式である*構築されたデータ*、ネットワーク内のリソースを指す*参照*の3つの基本形式を区別できます。

```
<datatype>  ::= <primtype> | <constype> | <reftype>
```

### プリミティブデータ

*プリミティブ型*は、プリミティブデータの可能な形式を記述します。

数値を記述するプリミティブ型は、文法では分離されています。

```
<primtype> ::= <numtype> | ...
```

#### 自然数

型`nat`は、無制限の範囲の自然数（符号なし整数）を記述します。固定サイズの表現を持つ、8、16、32、または64ビットの値範囲に制限されたバリアントもあります。

```
<numtype> ::= nat | nat8 | nat16 | nat32 | nat64 | ...
```

**注：** 型`nat`の値は、バイナリシリアライズ形式では可変長の表現を持ち、したがって、その値の（対数に比例した）サイズを占有します。一般的な値が小さい限り、固定サイズの型よりもスペース効率が良い場合があります。

#### 整数

型`int`は、無制限の範囲の整数（符号付き）を記述します。固定サイズの表現を持つ、8、16、32、または64ビットの値範囲に制限されたバリアントもあります。

```
<numtype> ::= ... | int | int8 | int16 | int32 | int64 | ...
```

**注：** 型`int`の値は、バイナリシリアライズ形式では可変長の表現を持ち、したがって、その値の（対数に比例した）サイズを占有します。一般的な値が小さい限り、固定サイズの型よりもスペース効率が良い場合があります。

#### 浮動小数点数

浮動小数点値はIEEE 754バイナリ形式で表現され、単精度（32ビット）と倍精度（64ビット）でサポートされています。

```
<numtype> ::= ... | float32 | float64
```

#### ブール値

ブール真理値は、型`bool`で表現されます。

```
<primtype> ::= ... | bool | ...
```

#### テキスト

テキスト文字列は、型`text`で表現され、Unicodeスカラー値のシーケンスで構成されます。

```
<primtype> ::= ... | text | ...
```

**注：** `text`型は、バインディングが適切な文字列型にマッピングできるように、また、バイナリ形式が効率的な内部表現を独立して選択できるようにするために、`vec nat8`（UTF-8文字列）または`vec nat32`（コードポイントのシーケンス）とは区別されます。

#### Null

型`null`は、厳密に1つの値（*null*値）を持ち、したがって情報を持っていません。たとえば、将来のアップグレードでレコードに追加されるべきオプションのフィールドのプレースホルダーとして、または下記に示す値が必要ない*バリアントケース*に使用できます。

```
<primtype> ::= ... | null | ...
```

#### 予約済み

型`reserved`は、無視されるべき未知のコンテンツを持つ型です。その目的は、後方/前方互換性の問題を回避するために、レコード内のフィールドIDを占有することです。以下のレコード型の説明を参照してください。

```
<primtype> ::= ... | reserved
```

**注：** この型は、protobufの*予約済みフィールド*と同様の役割を果たします。

#### 空

型`empty`は、存在しない値の型です。その目的は、実際には存在しないバリアント、または関数参照の引数型として、それらが呼び出されないことを示すことです。

```
<primtype> ::= ... | empty
```

### 構築されたデータ

*構築された型*は、値の複合形式または集約形式を記述します。

#### オプション

*オプション*は、特定のデータ型の値であり、存在しない可能性があります。

```
<constype>  ::= opt <datatype> | ...
```

#### ベクトル

*ベクトル*は、同じデータ型の値の*均質な*シーケンスです。

```
<constype>  ::= ... | vec <datatype> | ...
```

##### 省略記法：Blob

特定のベクトル*blob*（任意のバイトシーケンス）には省略記法があります。

```
<constype> ::= ....
  | blob   := vec nat8
```

#### レコード

*レコード*は、異なるデータ型の値の*異質な*シーケンスです。各値には*フィールドID*（レコード内で一意でなければならず、指定されたデータ型の単一の値を持つ数値）がタグ付けされています。フィールドが指定される順序は重要ではありません。

```
<constype>  ::= ... | record { <fieldtype>;* } | ...
<fieldtype> ::= <nat> : <datatype>
```

レコード型における`<fieldtype>`リストは、順序の変更を無視して識別されます。

IDは、32ビットの値範囲に収まる必要がある単純な符号なし整数として記述されます。10進数または16進数表記で指定できます。

```
<nat> ::= (0..9)(_? 0..9)* | 0x(0..9|a..f|A..F)(_? 0..9|a..f|A..F)*
```

ID値は2^32未満でなければならず、同じレコード型内で同じIDが2回出現してはなりません。

##### 省略記法：シンボリックフィールドID

IDは*名前*として指定することもでき、これはその名前のハッシュである数値IDの省略記法です。

```
<fieldtype> ::= ...
  | <name> : <datatype>    :=  <hash(name)> : <datatype>
```

一意の（数値またはテキストの）IDによってフィールドを識別する目的は、関数の返すレコード型の安全なアップグレードをサポートすることです。関数の新しいバージョンは、以前に使用されていないIDを持つ限り、古いレコードに安全にフィールドを*追加*できます。詳細については、以下のアップグレードに関する議論を参照してください。

ハッシュ関数は次のように指定されます。

```
hash(id) = ( Sum_(i=0..k) utf8(id)[i] * 223^(k-i) ) mod 2^32 where k = |utf8(id)|-1
```

この展開は、単一のレコード内のフィールド名間のハッシュ衝突が許可されないことを意味します。

このハッシュ関数には、次の有用な特性があります。

* 衝突は十分にまれです。[長さ4までの名前には衝突がありません](https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf)。
* （例えば、暗号学的ハッシュ関数と比較して）実装がかなり簡単です（衝突攻撃に対する耐性は必要ありません）。

ハッシュ関数は、すべての数値を人間が読めるプレイメージに変換できるという特性を持っていません。数値フィールド名をサポートできないホスト言語は、数値フィールド名とホスト言語で有効でないフィールド名の適切なテキストエンコーディングを考案する必要があります。

##### 省略記法：タプルフィールド

フィールドIDは完全に省略することもでき、これは（最初のフィールドの場合は0、前のフィールドのIDがNの場合はN+1を選択する）省略記法にすぎません。

```
<fieldtype> ::= ...
  | <datatype>    :=  N : <datatype>
```

##### 例

```
record {
  name : text;
  street : text;
  num : nat;
  city : text;
  zip : nat;
}

record { nat; nat }
record { 0 : nat; 1 : nat }
```

後者の2つのレコードは同等です。


#### バリアント

*バリアント*は、異なる可能性のあるデータ型のタグ付きユニオンです。タグは、バリアントケースを一意に決定する数値IDによって与えられます。各ケースはフィールドとして記述されます。フィールドが指定される順序は重要ではありません。

```
<constype>  ::= ... | variant { <fieldtype>;* } | ...
```

バリアント型における`<fieldtype>`リストは、順序の変更を無視して識別されます。

フィールドIDは2^32未満でなければならず、同じバリアント型内で同じIDが2回出現してはなりません。

##### 省略記法：シンボリックタグID

レコードフィールドと同様に、バリアントタグのIDも*名前*として指定でき、これはそのハッシュの省略記法です。

##### 省略記法：列挙型

バリアントフィールドの型は省略でき、その場合は`null`になります。

```
<fieldtype> ::= ...
  | <nat>    :=  <nat> : null
  | <name>   :=  <name> : null
```

この省略記法はバリアントにのみ適用されます。同時に、バリアントではフィールドIDを省略するためのタプルフィールドの省略記法は許可されていません。

##### 例

```
type color = variant { red; green; blue };

type tree = variant {
  leaf : int;
  branch : record {left : tree; val : int; right : tree};
}
```

### 参照

3番目の値の形式は*参照*です。これらは、（おそらくリモートの）*関数*、*サービス*、または*プリンシパル*への第一級のハンドルを表します。

#### サービス参照

*サービス参照*はサービスを指し、アクター型によって記述されます。これにより、サービスは他のサービスへの接続を通信できます。

```
<reftype> ::= ... | service <actortype>
```

##### 例

```
type broker = service {
  findCounterService : (name : text) ->
    (service {up : () -> (); current : () -> (nat)});
}
```

#### 関数参照

*関数参照*は、その関数型によって記述されます。たとえば、これにより、コールバックを他の関数に渡すことができます。

```
<reftype> ::= func <functype> | ...
```

##### 例

```
type engine = service {
  search : (query : text, callback : func (vec result) -> ());
}
```

#### プリンシパル参照

*プリンシパル参照*は、カニスターやユーザーなどのアイデンティティを指します。これにより、他のサービスやユーザーを認証または認可できます。型コンストラクタは引数を取らないため、*プリミティブ*型として分類されます。

```
<primtype> ::= ... | principal | ...
```

### 型定義

型は*型定義*によって名前を付けることができます。

```
<def>   ::= type <id> = <datatype>
```

型定義は相互に再帰的です。つまり、自身または互いに参照できます。ただし、すべての型サイクルは生産的でなければなりません。つまり、単なる識別子ではない型表現を経由する必要があります。*空虚な*型定義、つまり自身と等しいだけの型定義は許可されません。

##### 例

```
type stream = opt record {head : nat; next : func () -> stream};
```

```
type node = record {head : nat; tail : list};
type list = opt node;
```

```
type A = B;
type B = A;  // エラー: 循環的な型定義
```

### インポート

インターフェース定義を複数のファイルに分割したり、複数のインターフェース間で共通の定義を共有したりするために、*インポート*宣言が用意されています。

```
<def>   ::= ... | import service? <text>
```

インポートは、URLによって別のインターフェースファイルを参照します。インポートされたファイルからの型定義は、インポートするファイルにテキストとして含まれます。インポートされたファイルからの定義は、インポートするファイルからの定義を参照してはなりません。

`import`は、インポートされたファイルからのメインサービス定義を無視しますが、`import service`は、インポートされたファイルからのメインサービスを含み、サービス定義をインポートするファイルのメインサービスとマージします。インポートされたファイルのメインサービス定義には、次の2つの制約があります。

* メインサービスはサービスコンストラクタであってはなりません。
* インポートされたファイルからのメソッドは、インポートするファイルと同じメソッド名を持ってはなりません。

##### 例

ファイル `A.did`:

```
type A = service { f : () -> () };
service : A
```

ファイル `B.did`:

```
import "A.did";  // メソッド名の重複のため `import service` は使用できません
service B : A ;
```

未解決の疑問：フラットな名前空間の代わりに、インポートに修飾名が必要でしょうか？

### インターフェース

*インターフェース記述*は、一連のインポートと型定義で構成され、場合によってはサービス宣言が続きます。サービス宣言は、アクター型を指定することにより、サービスアクターに名前を付け、指定します。アクター型は、アクター参照型の型定義の名前を参照することによっても指定できます。

```
<desc>  ::= <def>;* <service>;?
<service> ::= service <id>? : (<actortype> | <id>)
```

インターフェース記述でサービスに与えられたオプションの名前は重要ではありません。それはドキュメントとしてのみ機能します。

## 値

便利なデバッグを可能にするために、次の文法は値のテキスト形式を指定します。これらの値の型はコンテキストから既知であると想定されているため、構文は自己記述的ではありません。

```
<val> ::=
  | <primval> | <consval> | <refval>
  | ( <annval> )

<annval> ::=
  | <val>
  | <val> : <datatype>

<primval> ::=
  | <nat> | <int> | <float>
  | <text>
  | true | false
  | null

<consval> ::=
  | opt <val>
  | vec { <annval>;* }
  | record { <fieldval>;* }
  | variant { <fieldval> }

<fieldval> ::= <nat> = <annval>

<refval> ::=
  | service <text>             (カニスターURI)
  | func <text> . <name>       (カニスターURIとメッセージ名)
  | principal <text>           (プリンシパルURI)

<arg> ::= ( <annval>,* )

<letter> ::= A..Z | a..z
<digit>  ::= 0..9
<id>     ::= (<letter> | _)(<letter> | <digit> | _)*

<sign>   ::= + | -
<hex>    ::= <digit> | A..F | a..f
<num>    ::= <digit>(_? <digit>)*
<hexnum> ::= <hex>(_? <hex>)*
<nat>    ::= <num> | 0x<hexnum>
<int>    ::= <sign>? <num>
<float>  ::=
  | <sign>? <num> . <num>?
  | <sign>? <num> (. <frac>?)? (e | E) <sign>? <num>
  | <sign>? 0x<hexnum> . <hexnum>?
  | <sign>? 0x<hexnum> (. <hexnum>?)? (p | P) <sign>? <num>

<text>   ::= " <char>* "
<char>   ::=
  | <utf8>
  | \ <hex> <hex>
  | \ <escape>
  | \u{ <hexnum> }
<escape>  ::= n | r | t | \ | " | '
<utf8>    ::= <ascii> | <utf8enc>
<ascii>   ::= '\20'..'\7e' except " or \
<utf8enc> ::=
  | '\c2'..'\df' <utf8cont>
  | '\e0' '\a0'..'\bf' <utf8cont>
  | '\ed' '\80'..'\9f' <utf8cont>
  | '\e1'..'\ec' <utf8cont> <utf8cont>
  | '\ee'..'\xef' <utf8cont> <utf8cont>
  | '\f0' '\90'..'\bf' <utf8cont> <utf8cont>
  | '\f4' '\80'..'\8f' <utf8cont> <utf8cont>
  | '\f1'..'\f3' <utf8cont> <utf8cont> <utf8cont>
<utf8cont> ::= '\80'..'\bf'
```

`<char>`は、*Unicodeスカラー値*（つまり、サロゲート部分ではないコードポイント）です。

#### 構文糖衣

型と同様に、いくつかの構文糖衣がサポートされており、基本的な値の形式に還元できます。

```
<consval> ::= ...
  | blob <text>            := vec { N;* }  ここで N;* は文字列内のバイトシーケンスであり、[WebAssemblyテキスト形式](https://webassembly.github.io/spec/core/text/values.html#strings)のように解釈されます。

<fieldval> ::= ...
  | <name> = <annval>      :=  <hash(name)> = <annval>
  | <annval>               :=  N = <annval>  ここで N は 0 または前の値 + 1 (レコード内のみ)
  | <nat>                  :=  <nat> = null   (バリアント内のみ)
  | <name>                 :=  <name> = null  (バリアント内のみ)
```

## アップグレードとサブタイピング

インターフェースは、既存のクライアントコードを壊すことのない*堅牢な*方法で、時間とともに進化することが許可されています。この概念を正確に捉えるために、型`T`のサービスは、別の型`T'`を持つバージョンに*アップグレード可能*であるのは、`T'`が`T`の*構造的部分型*である場合、つまり`T' <: T`と書ける場合に限ります。この関係は、`T'`が`T`よりも*特殊化*されていることを表します。（注：より特殊化された型は、より一般的ではなく、可能な値のより小さな集合を示すため、サブタイプレコードは*より多くの*フィールドを持つことができますが、サブタイプ順序の方向はこのようになります。）

サービスとクライアント間で渡されるデータ構造をアップグレードする場合、データの流れの方向を区別することが重要です。アップグレードの要件は互いに逆になるためです。

* サービスからクライアントへのメッセージ結果として返される*アウトバウンド*データは、サービスによって*提供*されます。アップグレードは、クライアントを壊すことなく、*より多くの*またはより洗練されたデータを提供できます。たとえば、アウトバウンドレコードは、アップグレード後に追加のフィールドを提供できます。

* クライアントからサービスへのメッセージパラメータとして渡される*インバウンド*データは、サービスによって*要求*されます。アップグレードは、クライアントを壊すことなく、*より少ない*またはより非特定的なデータのみを要求できます。たとえば、インバウンドレコードは、アップグレード後に必要なフィールドが少なくなる可能性があります。

つまり、アウトバウンドメッセージの結果は、アップグレードではサブタイプ（より多くのフィールド）でのみ置き換えることができ、インバウンドメッセージのパラメータは、スーパータイプ（より少ないフィールド）でのみ置き換えることができます。これは、型システムの共変性と反変性の概念に対応しています。

サブタイピングは、フィールド自体の型に再帰的に適用されます。さらに、サブタイピングの方向は、標準的な規則に従って、インバウンド関数およびサービス参照では*反転*されます。

通常のサブタイピング規則に加えて、サブタイピング関係にはいくつかのより珍しい規則があります。特に、それらは、それらがオプションである限り、インバウンド値にフィールドを*追加*すること（および逆に、アウトバウンド値から削除すること）も許可します。同様に、バリアント自体がオプションである限り、インバウンド値からケースを*削除*すること（および逆に、アウトバウンド値に追加すること）を許可します。これらすべてのケースで、タグまたはフィールドを処理できない受信者は、単に`null`を見ます。これにより、堅牢性を維持しながら、時間とともにインターフェースを進化させる際の最大限の柔軟性が可能になります。

### 例

たとえば、代表的なケースは、次の形式のインターフェースです。

```
// バージョン 1
type t = {x : nat};
service : {
  produce : () -> t;
  consume : t -> ();
}
```

サブタイピング規則により、後で型`t`に追加のフィールドを追加できます。ただし、それらがオプション型で指定されている場合に限ります。

```
// バージョン 2
type t = {x : nat; y : opt nat};
service : {
  produce : () -> t;
  consume : t -> ();
}
```

通常のサブタイピング規則の下では、このようなレコード拡張は通常、`consume`関数の場合など、`t`がインバウンド位置で発生すると互換性がない（健全でない）ため、これは許可されません。新しいフィールドを認識していない既存のクライアントが存在し、それらを提供できずに失敗する可能性があります。ただし、そのようなフィールドをオプション型に制限し、欠落している場合は`null`として解釈することにより、そのような不一致は解消されます。

このような拡張性は、関数自体がパラメータになる*高階*の例にも拡張されます。

```
type t = {x : nat};
service : {
  h1 : (f1 : () -> t) -> ();      // f1() を呼び出し、t を期待する可能性がある
  h2 : (f2 : t -> ()) -> ();      // f2({x = 5}) を呼び出す可能性がある
}
```

型`t`が後で新しいオプションのフィールドで拡張された場合、この変更をまだ認識していない`f1`または`f2`に関数を渡す既存のクライアントは、引き続き正しく動作します。これは任意の順序で適用できます。たとえば、次のシナリオでは、`t`に新しいオプションのフィールドを安全に追加できます。

```
type t = {x : nat};
type f = t -> ();
type g = () -> t;
service : {
  h : (f, g) -> ();    // f(g()) を合成する可能性がある
}
```

### 設計目標

要約すると、アップグレードの検証のためのサブタイピング関係は、次の設計目標を念頭に置いて設計されています。

* 健全性：サブタイピングは、スーパータイプでのデシリアライズが失敗しないことを意味します。
* 完全性：サブタイピングは、成功したデシリアライズのすべてのケースを網羅します。
* 推移性：サブタイピングは、複数のアップグレードにわたってもデシリアライズが失敗しないことを意味します。
* レコード拡張性：レコードは、アウトバウンドとインバウンドの両方の位置にある場合でも、新しい（オプションの）フィールドを追加することによってアップグレード可能であり、ラウンドトリップは常に可能です。
* 高階拡張性：サブタイピングは、関数がパラメータになる高階のケースに拡張されるため、それらの入出力コントラクトに固有の所有者はいません。
* 言語射影性：サブタイピングは、ソース言語に対応するものがないインターフェースのバージョンまたは役割のアノテーションに依存しません。つまり、特別な機能やクロスバージョン知識なしに、ソースレベルの型からインターフェース記述を生成できます。
* 簡単なデシリアライズ：デシリアライズには、値のblobの型指向トラバーサル以外の（サブ）型チェックは必要ありません。
* 型消去：デシリアライズされた値は、言語側で動的な型情報を保持する必要はありません。特に、サービス参照と関数参照は、型情報なしで表現できます。
* 隠れたチャネルなし：シリアライズは、送信者が認識していない値を決して含みません。具体的には、送信者が以前に受信した値を第三者に渡す場合、それは送信者の型ごとの送信意図のあるフィールドのみを含みます。

ただし、何かを譲らなければなりません。したがって、維持されていないように見える望ましい特性の1つは、*推移的なコヒーレンス*です。つまり、ある型でシリアライズされ、スーパータイプでデシリアライズおよびシリアライズされ、さらにスーパータイプのスーパータイプでデシリアライズされた値は、後者のスーパータイプで直接デシリアライズされた場合とは異なる結果になる可能性があります。ただし、唯一可能な違いは、オプションの値の代わりに`null`を取得するか、またはその逆になることです。

### 規則

#### プリミティブ型

ほとんどのプリミティブ型はアップグレードで変更できません。

```
------------------------
<primtype> <: <primtype>
```

例外は整数であり、自然数に特殊化できます。

```
-----------
nat <: int
```

`empty`と`reserved`には追加の規則が適用され、これらはそれぞれボトム型とトップ型になります。

```
-------------------------
<datatype> <: reserved


--------------------
empty <: <datatype>
```

#### ベクトル

ベクトル型は、その構成型によって特殊化できます。

```
<datatype> <: <datatype'>
---------------------------------
vec <datatype> <: vec <datatype'>
```

#### オプション

オプション型は、その構成型によって特殊化できます。

```
<datatype> <: <datatype'>
---------------------------------
opt <datatype> <: opt <datatype'>
```

さらに、オプション型は`null`に特殊化できます。

```
------------------------
null <: opt <datatype>
```

その型自体がオプションでない限り、その構成型に特殊化することもできます。

```
not (null <: <datatype'>)
<datatype> <: <datatype'>
-----------------------------
<datatype> <: opt <datatype'>
```

前提条件は、構成型自体が`null`、オプション、または`reserved`の場合、この規則が適用されないことを意味します。その制限は、曖昧さを避けるために必要です。たとえば、そうでない場合、`opt nat`から`opt opt nat`に移行するときに、`null`または`?null`の2つの解釈方法が存在することになります。

最後に、サブタイピングの*推移性*を維持するために、2つの珍しい規則により、実際には*任意の*型をオプションのサブタイプと見なすことができます。

```
not (<datatype> <: opt <datatype'>)
---------------------------------
opt <datatype> <: opt <datatype'>

not (null <: <datatype'>)
not (<datatype> <: <datatype'>)
---------------------------------
opt <datatype> <: opt <datatype'>
```

*注：*これらの規則は、以下に示す珍しいレコード規則とバリアント規則が存在する場合に必要です。それらがなければ、特定のアップグレードは一度に1ステップずつでは一般的に有効である可能性がありますが、まとめて行うことはできず、複数のアップグレードに追いつくクライアントに問題を引き起こす可能性があります。
たとえば、レコード型`record {666 : nat}`の場合、以下の規則によってフィールド`666`を削除し、型を`record { 666 : opt nat }`、そして`record {}`に進化させることは有効です。
後のステップでは、同じ名前で異なる型のフィールドを合法的に再追加し、たとえば`record {666 : opt text}`を生成する可能性があります。
いくつかの中間ステップを見逃したクライアントは、型の最新バージョンに直接アップグレードする必要があります。
型をデコードできない場合、その値は`null`として扱われます。

実際には、レコードフィールドまたはバリアントタグを削除し、後で異なる意味で再追加することは、ユーザーに強く推奨されません。オプションのレコード/バリアントフィールドを削除する代わりに、そのフィールドの再利用を防ぐために、`opt empty`または`reserved`に置き換える必要があります。
ただし、型システムがこれを防ぐ一般的な方法はありません。型定義の履歴を知ることができないためです。
したがって、上記の規則は、実際的な理由よりも技術的な理由で必要です。
静的アップグレードチェックの実装では、この規則が使用された場合に警告を発することが推奨されます。

#### レコード

特殊化されたレコード型では、レコードフィールドの型を特殊化したり、フィールドを追加したりできます。

```
---------------------------------------
record { <fieldtype'>;* } <: record { }

<datatype> <: <datatype'>
record { <fieldtype>;* } <: record { <fieldtype'>;* }
----------------------------------------------------------------------------------------------
record { <nat> : <datatype>; <fieldtype>;* } <: record { <nat> : <datatype'>; <fieldtype'>;* }
```

インバウンド位置（つまり、関数の結果と関数のパラメータの両方として使用される）にも出現するレコード型を進化および拡張できるようにするために、サブタイピング関係は、オプション、null、または`reserved`である場合に、レコードからフィールドを*削除*することもサポートしています。

```
<nat> not in <fieldtype>;*
record { <fieldtype>;* } <: record { <fieldtype'>;* }
null <: <datatype'>
------------------------------------------------------------------------------
record { <fieldtype>;* } <: record { <nat> : <datatype'>; <fieldtype'>;* }
```

\*注：\*この規則は、通常のサブタイピングの観点からは珍しいものですが、実際には必要です。前の規則と合わせて、使用方法に関係なく、アップグレード時に任意のレコードにオプションのフィールドを追加できます。拡張機能を認識していない当事者は、そのフィールドを`null`として扱います。

#### バリアント

特殊化されたバリアントの場合、タグの型を特殊化したり、タグを削除したりできます。

```
-----------------------------------------
variant { } <: variant { <fieldtype'>;* }

<datatype> <: <datatype'>
variant { <fieldtype>;* } <: variant { <fieldtype'>;* }
------------------------------------------------------------------------------------------------
variant { <nat> : <datatype>; <fieldtype>;* } <: variant { <nat> : <datatype'>; <fieldtype'>;* }
```

*注：*上記の`opt`に関する規則により、バリアント自体がオプションである場合（例：`opt variant { 0 : nat; 1 : bool } <: opt variant { 1 : bool }`）、バリアントにタグを*追加*することで、アウトバウンド位置（つまり、関数の結果と関数のパラメータの両方として使用される）にも出現するバリアント型を進化および拡張できます。拡張機能を認識していない当事者は、新しいケースを`null`として扱います。

#### 関数

特殊化された関数では、任意のパラメータ型を一般化し、任意の結果型を特殊化できます。さらに、引数を削除でき、結果を追加できます。つまり、規則はタプルのようなレコードの規則を反映しています。つまり、順序付けられており、末尾でのみ拡張できます。

```
record { (N1' : <datatype1'>);* } <: record { (N1 : <datatype1>);* }
record { (N2 : <datatype2>);* } <: record { N2' : <datatype2'>);* }
-------------------------------------------------------------------------------------------------------------------
func ( <datatype1>,* ) -> ( <datatype2>,* ) <funcann>* <: func ( <datatype1'>,* ) -> ( <datatype2'>,* ) <funcann>*
```

ここで、`NI*`はそれぞれ`<nat>`シーケンス`1`..`|<datatypeNI>*|`です。

集合として見ると、関数の注釈は等しくなければなりません。

#### サービス

サービスの場合、メソッドを特殊化（その関数型を特殊化することによって）したり、メソッドを追加したりできます。本質的に、それらは関数のレコードのように扱われます。

```
----------------------------------------
service { <methtype'>;* } <: service { }

<functype> <: <functype'>
service { <methtype>;* } <: service { <methtype'>;* }
------------------------------------------------------------------------------------------------
service { <name> : <functype>; <methtype>;* } <: service { <name> : <functype'>; <methtype'>;* }
```

### 強制

このサブタイピングは、期待される型でのCandidのデシリアライズ中に実装されます。[セクション デシリアライズ](https://www.google.com/search?q=%23deserialisation)で説明されているように、バイナリ値は概念的には最初に実際の型とその型の値に*デコード*され、次にその値が期待される型に*強制*されます。

このセクションでは、型`T`の値`V`が型`T'`の値`V'`に強制できる場合を記述する関係`V : T ~> V' : T'`として、強制について説明します。フィールド`V`、`T`、および`T'`は入力として、`V'`はこの関係の出力として理解できます。これらの値を記述するために、テキスト表現の構文を再利用します。

#### プリミティブ型

プリミティブ型では、強制は恒等関数です。

```
<t> ∈ <numtype>, bool, text, null
---------------------------------
<v> : <t> ~> <v> : <t>
```

型`nat`の値は型`int`に強制されます。

```
--------------------------
<nat> : nat ~> <nat> : int
```

`reserved`への強制は定数マップです（これは`reserved`の「値」として任意に`null`を使用しています）。

```
--------------------------
_ : <t> ~> null : reserved
```

注意：型`empty`には規則は必要ありません。その型の値は存在しないためです。構成上、`_ : empty ~> _ : _`は成立しません。

#### ベクトル

ベクトルは要素ごとに強制されます。

```
<v> : <t> ~> <v'> : <t'>
----------------------------------------------------
vec { <v>;* } : vec <t> ~> vec { <v'>;* } : vec <t'>
```

#### オプション

null値は任意のオプション型に強制されます。

```
null <: <t>
-----------------------------
null : <t> ~> null : opt <t'>
```

オプションの値は、構成値が適切な型を持っている場合はオプション型に強制され、そうでない場合は`null`になります。

```
<v> : <t> ~> <v'> : <t'>
----------------------------------------
opt <v> : opt <t> ~> opt <v'> : opt <t'>

not (<v> : <t> ~> _ : <t'>)
----------------------------------------
opt <v> : opt <t> ~> null : opt <t'>
```

null、オプション、および予約済みでない型をオプション型に強制すると、正常にデコードできる場合はオプションの値として扱われます。

```
not (null <: <t>)
not (null <: <t'>)
<v> : <t> ~> <v'> : <t'>
--------------------------------
<v> : <t> ~> opt <v'> : opt <t'>
```

他のすべての値は`null`になります。

```
---------------------------------
<v> : reserved ~> null : opt <t'>

not (null <: <t'>)
not (<v> : <t> ~> _ : <t'>)
--------------------------------
<v> : <t> ~> null : opt <t'>

null <: <t'>
not (null <: <t>)
----------------------------
<v> : <t> ~> null : opt <t'>
```


#### レコード

次の規則では、

* `<nat1>*` フィールド名は、実際の型と期待される型の両方に存在するものです。値は強制されます。
* `<nat2>*` フィールド名は、実際の型にのみ存在するものです。値は無視されます。
* `<nat3>*` フィールド名は、期待される型にのみ存在するものであり、したがって null、オプション、または予約済みの型である必要があります。これらの値には `null` が使用されます。

```
<v1> : <t1> ~> <v1'> : <t1'>
null <: <t3>
-------------------------------------------------------------------------------------------
record { <nat1> = <v1>;* <nat2> = <v2>;* } : record { <nat1> : <t1>;* <nat2> : <t2>;* } ~>
record { <nat1> = <v1'>;* <nat3> = null;* } : record { <nat1> : <t1'>;* <nat3> : <t3>;* }
```

#### バリアント

期待されるタグを持つバリアント値のみがバリアント型に強制されます。

```
<v> : <t> ~> <v'> : <t'>
----------------------------------------------------------
variant { <nat> = <v>; } : variant { <nat> : <t>; _;* } ~>
variant { <nat> = <v'> } : variant { <nat> : <t'>; _;* }
```

#### 参照

関数とサービスの参照値の場合、強制関係は、指定された型が実際に期待される型のサブタイプであるかどうかを確認し、そうでない場合は失敗します。

```
func <functype> <: func <functype'>
---------------------------------------------------------------------
func <text>.id : func <functype> ~> func <text>.id : func <functype'>

service <actortype> <: service <actortype'>
-----------------------------------------------------------------------------
service <text> : service <actortype> ~> service <text> : service <actortype'>

------------------------------------------------------------
principal <text> : principal ~> principal <text> : principal
```

注：上記の規則は、Candidデコーダーが参照型のサブタイピング関係を決定できる必要があることを意味します。

#### タプル型

引数と結果のシーケンス全体は、タプルのようなレコードと同じ規則で強制されます。特に、余分な引数は無視され、引数が欠落しているか強制に失敗した場合、オプション/nullパラメータは `null` として読み取られます。

```
record { <v>;* } : record { <t>;* } ~> record { <v'>;* } : record { <t'>;* }
----------------------------------------------------------------------------
(<v>,*) : (<t>,*) ~> (<v'>,*) : (<t'>,*)
```

## プロパティ

上記の関係には特定のプロパティがあります。前のセクションと同様に、`<v> : <t>` は `<v>` が本質的に型 `<t>` を持つことを意味します。

* サブタイピングの反射性:
  ```
  <t> <: <t>
  ```

* サブタイピングの推移性:
  ```
  <t> <: <t'>, <t'> <: <t''> ⇒ <t> <: <t'>
  ```

* ラウンドトリップ:
  ```
  (<v> : <t>) ⟺ <v> : <t> ~> <v> : <t>
  ```

* 型付けの健全性:
  ```
  <v> : <t> ~> <v'> : <t'> ⇒ <v'> : <t'>
  ```

* サブタイピングの健全性 (または、強制のwell-definedness):
  ```
  <t> <: <t'> ⇒ ∀ <v> : <t> ∃ <v'>. <v> : <t> ~> <v'> : <t'>
  ```

* 高階サブタイピングの健全性
  <./IDL-Soundness.md> を参照。ただし、以下のインスタンス化を使用します。
  ```
  s1 ~> s2 ≔ s2 <: s1
  t1 <: t2 ≔ t1 <: t2
  s1 in t1 <: s2 in t2 ≔ (未定義)
  s1 <:h s2 ≔ (ホスト言語依存)
  ```

* 注意: 推移的なコヒーレンスは成立しません:
  ```
  <v1> : <t1> ~> <v2> : <t2>
  <v2> : <t2> ~> <v3> : <t3>
  <v1> : <t1> ~> <v3'> : <t3>
  ```
  は、
  ```
  <v3> = <v3'>
  ```
  を意味しません。

  ただし、`<v3> ~ <v3'>` を意味します。ここで、~ は `∀ v. opt v ~ null` を満たす最小の準同型、反射的、対称的な関係です。

「サブタイピングの完全性」の目標は、まだ正式な定式化には至っていません。

## バイナリ形式

実行時、すべてのCandid値はトリプル (T, M, R) にシリアライズされます。ここで、T ("type") と M ("memory") はバイトシーケンスであり、R ("references") は参照のシーケンスです。R が空の場合、省略できます。

データの型を明示的にすることで、(1) シリアライズされたデータは自己記述的になり、ツールに役立ちます。(2) エラーの発見と処理が改善されます。(3) バイナリ形式はバージョニングの問題から分離されるため、後者はより柔軟に設計できます。

参照を使用することで、(1) 参照値のワイヤー表現 (複雑で型などのシステムメタデータを含む可能性がある) をクライアントコードに公開する必要がなくなり、(2) システムはシリアライズされたデータ内の参照の位置を知っているため、必要に応じてそれらを書き換え/マッピング/フィルタリング/調整できます。

したがって、シリアライズは、それぞれのコンポーネントを生成する3つのマッピング関数 `T`、`M`、および `R` によって定義されます。

注意:

* 必須ではありませんが、シリアライザーは、サブタイピング関係に関して値の*プリンシパル*型を最初に計算することにより、シリアライズされた型のサイズを最小化できます。特に、バリアント型は必要な以上のフィールドを含む必要はありません。たとえば、`E = variant { A, B, C }` で、シリアライズする値が型 `E` の `A` である場合、型 `variant { A }` でシリアライズできます。同様に、値がベクトル `[C, A, C]` の場合、プリンシパル型 `vec (variant { A, C })` で十分です。

### シリアライズ

このセクションでは、Candid によって記述された型の抽象的な *Candid 値* が、サービス間での転送のためにバイナリ表現にシリアライズされる方法について説明します。

シリアライズは、以下に示す3つの関数 `T`、`M`、および `R` によって定義されます。

ほとんどの Candid 値は自己説明的ですが、参照は例外です。サービス参照とプリンシパル参照には、次の2つの形式の Candid 値があります。

* `ref(r)` は、基盤となるシステムのみが理解できる不透明な参照を示します。
* `id(b)` は、blob `b` によってアドレス指定されるサービスへの透過的な参照を示します。

同様に、関数参照には、次の2つの形式の Candid 値があります。

* `ref(r)` は、基盤となるシステムのみが理解できる不透明な参照を示します。
* `pub(s,n)` は、`s` によって参照されるサービスの公開メソッド名 `n` を示します。

#### 表記

`T` と `M` は、自然なストレージ型 (`N = 8, 16, 32, 64` の `i<N>`、`N = 32, 64` の `f<N>`) で記述されたバイトシーケンスを作成します。バイトは、重要度の低い順 (リトルエンディアン) に並べられます。

次の表記が使用されます。

* `.` は空のバイトシーケンス
* `x1 x2` は連結
* `t^N`、`t+`、`t*`、`t?` は、それぞれ `N` 回、`N>0` 回、`N>=0` 回、または `N<=1` 回の繰り返しシーケンス
* `leb128` と `sleb128` は、符号なしおよび符号付きの [LEB128](https://en.wikipedia.org/wiki/LEB128) エンコーディング
* `utf8` は、テキスト文字列の UTF-8 エンコーディング (0 終端ではない)

#### 型

`T` は、Candid 型をその型を表すバイトシーケンスにマッピングします。
各型コンストラクタは、負のオペコードとしてエンコードされます。
レコード型またはバリアント型のフィールドは ID の昇順にソートされ、サービスのメソッドは名前の昇順にソートされていると仮定します。

```
T : <primtype> -> i8*
T(null)      = sleb128(-1)  = 0x7f
T(bool)      = sleb128(-2)  = 0x7e
T(nat)       = sleb128(-3)  = 0x7d
T(int)       = sleb128(-4)  = 0x7c
T(nat8)      = sleb128(-5)  = 0x7b
T(nat16)     = sleb128(-6)  = 0x7a
T(nat32)     = sleb128(-7)  = 0x79
T(nat64)     = sleb128(-8)  = 0x78
T(int8)      = sleb128(-9)  = 0x77
T(int16)     = sleb128(-10) = 0x76
T(int32)     = sleb128(-11) = 0x75
T(int64)     = sleb128(-12) = 0x74
T(float32)   = sleb128(-13) = 0x73
T(float64)   = sleb128(-14) = 0x72
T(text)      = sleb128(-15) = 0x71
T(reserved)  = sleb128(-16) = 0x70
T(empty)     = sleb128(-17) = 0x6f
T(principal) = sleb128(-24) = 0x68

T : <constype> -> i8*
T(opt <datatype>) = sleb128(-18) I(<datatype>)              // 0x6e
T(vec <datatype>) = sleb128(-19) I(<datatype>)              // 0x6d
T(record {<fieldtype>^N}) = sleb128(-20) T*(<fieldtype>^N)  // 0x6c
T(variant {<fieldtype>^N}) = sleb128(-21) T*(<fieldtype>^N) // 0x6b

T : <fieldtype> -> i8*
T(<nat>:<datatype>) = leb128(<nat>) I(<datatype>)

T : <reftype> -> i8*
T(func (<datatype1>*) -> (<datatype2>*) <funcann>*) =
  sleb128(-22) T*(<datatype1>*) T*(<datatype2>*) T*(<funcann>*) // 0x6a
T(service {<methtype>*}) =
  sleb128(-23) T*(<methtype>*)                                    // 0x69

T : <methtype> -> i8*
T(<name>:<datatype>) = leb128(|utf8(<name>)|) i8*(utf8(<name>)) I(<datatype>)

T : <funcann> -> i8
T(query)  = i8(1)
T(oneway) = i8(2)
T(composite_query) = i8(3)

T* : <X>* -> i8*
T*(<X>^N) = leb128(N) T(<X>)^N
```

すべてのネストされた型は、負のオペコードによるプリミティブ型、または正の数による*型定義*のリストへのインデックスとしてエンコードされます。これにより、再帰型と複数回発生する型の共有が可能になります。

```
I : <datatype> -> i8*
I(<primtype>) = T(<primtype>)
I(<comptype>) = sleb128(i)  where type definition i defines T(<datatype>)
```

型定義自体は、シリアライズされたデータ型のリストとして表現されます。

```
T*(<comptype>*)
```

このリストのデータ型は、`I` を介して互いに (または自身を) 参照できます。

注意:

* 型定義のプレフィックスのため、任意のシリアライズされた型を表す複数の可能な方法が常に存在します。したがって、型シリアライズは技術的には関数ではなく関係です。

* メソッド型を表すシリアライズされたデータ型は、関数型を示す必要があります。

* 再帰は `T` を介して行われるため、この形式は構成上、`type t = t` のような非well-foundedな定義を排除します。

* 型テーブルには、複合型のみを含めることができます (`<primtype>` は不可)。


#### メモリ

`M` は、Candid 値をその値を表すバイトシーケンスにマッピングします。定義は型によってインデックス付けされます。
レコード値のフィールドは ID の昇順にソートされていると仮定します。

```
M : <val> -> <primtype> -> i8*
M(n : nat)      = leb128(n)
M(i : int)      = sleb128(i)
M(n : nat<N>)   = i<N>(n)
M(i : int<N>)   = i<N>(signed_N^-1(i))
M(z : float<N>) = f<N>(z)
M(b : bool)     = i8(if b then 1 else 0)
M(t : text)     = leb128(|utf8(t)|) i8*(utf8(t))
M(_ : null)     = .
M(_ : reserved) = .
// NB: M(_ : empty) will never be called

M : <val> -> <constype> -> i8*
M(null : opt <datatype>) = i8(0)
M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
M(kv* : record {<fieldtype>*}) = M(kv : <fieldtype>)*
M(kv   : variant {<fieldtype>*}) = leb128(i) M(kv : <fieldtype>*[i])

M : (<nat>, <val>) -> <fieldtype> -> i8*
M((k,v) : k:<datatype>) = M(v : <datatype>)

M : <val> -> <reftype> -> i8*
M(ref(r) : service <actortype>) = i8(0)
M(id(v*) : service <actortype>) = i8(1) M(v* : vec nat8)

M(ref(r)   : func <functype>) = i8(0)
M(pub(s,n) : func <functype>) = i8(1) M(s : service {}) M(n : text)

M(ref(r) : principal) = i8(0)
M(id(v*) : principal) = i8(1) M(v* : vec nat8)
```

#### 参照

`R` は、Candid 値をその値に含まれる参照のシーケンスにマッピングします。定義は型によってインデックス付けされます。
レコード値のフィールドは ID の昇順にソートされていると仮定します。

```
R : <val> -> <primtype> -> <ref>*
R(_ : <primtype>) = .

R : <val> -> <constype> -> <ref>*
R(null : opt <datatype>) = .
R(?v   : opt <datatype>) = R(v : <datatype>)
R(v* : vec <datatype>) = R(v : <datatype>)*
R(kv* : record {<fieldtype>*}) = R(kv : <fieldtype>)*
R(kv   : variant {<fieldtype>*}) = R(kv : <fieldtype>*[i])

R : (<nat>, <val>) -> <fieldtype> -> <ref>*
R((k,v) : k:<datatype>) = R(v : <datatype>)

R : <val> -> <reftype> -> <ref>*
R(ref(r) : service <actortype>) = r
R(id(b*) : service <actortype>) = .
R(ref(r)   : func <functype>) = r
R(pub(s,n) : func <functype>) = .
R(ref(r) : principal) = r
R(id(b*) : principal) = .
```

注意:

* 参照 *r* が内部的にも外部的にもどのように表現されるかは指定されていません。Wasm にバインドする場合、それらの内部表現は Wasm 参照型、つまり `anyref` またはそのサブタイプに基づくと予想されます。ワイヤー上の参照テーブルをどのように表現または変換するかはシステムの責任です。

### パラメータと結果

`A` は引数マッピングを定義します。本質的に、引数リストは単一の閉じられたレコードであるかのように、トリプル (T, M, R) にシリアライズされます。T と M は、マジックナンバーとして文字列 "DIDL" と、可能な型定義リストが前に付加された単一のバイトストリーム B に結合されます。
引数の値は ID の昇順にソートされていると仮定します。

```
A(kv* : <datatype>*) = ( B(kv* : <datatype>*), R(kv* : <datatype>*) )

B(kv* : <datatype>*) =
  i8('D') i8('I') i8('D') i8('L')      magic number
  T*(<comptype>*)                      type definition table
  I*(<datatype>*)                      types of the argument list
  M(kv* : <datatype>*)                 values of argument list
```

ベクトル `T*(<comptype>*)` には、他の `<datatype>` ベクトルのシリアライズで参照される、任意のシーケンスの型定義 (上記参照) が含まれます。

関数結果にも同じ表現が使用されます。

注意:

* シリアライズされた値を表すペア (B, R) が外部環境でどのようにバンドルされるかは指定されていません。

### デシリアライズ

期待される型シーケンス `(<t'>,*)` でのデシリアライズは、次の手順で実行されます。

* マジックナンバー `DIDL` のチェック
* `T` 関数の逆関数を使用して、型定義 `(<t>,*)` をデコード
* `(<t>,*)` によってインデックス付けされた `M` 関数の逆関数を使用して、値 `(<v>,*)` をデコード
* 強制関数 `v : t ~> v' : t'` を使用して、デコードされた値を期待される型で理解

実装に関する注意:

ワイヤー形式とサブタイピングのため、固定された型シーケンス `(<t'>,*)` で異なるメッセージをデシリアライズするには、スタックサイズ、時間、メモリなど、大幅に異なるリソースが必要です。実装では、次のことを防ぐために、デシリアライズのコストを自己計測することが推奨されます。(1) スタックオーバーフロー、(2) サブタイピングによる不要なデータへの過度の時間消費、(3) 指数関数的なサイズのデータのデシリアライズ。

### 将来の型のデシリアライズ

デシリアライズでは、将来の拡張に対するロバスト性のために、次のメカニズムを使用します。

* シリアライズされた型は、上記の定義以外のオペコード (つまり、-24 未満) で始まる場合があります。そのようなオペコードの後には、LEB128 エンコードされたカウントと、このカウントに対応するバイト数が続きます。そのように表現された型は、*将来の型* と呼ばれます。

* 将来の型に対応する値は、*将来の値* と呼ばれます。これは、2つの LEB128 エンコードされたカウント *m* と *n*、それに続くメモリ表現 M の *m* バイト、および R 内の *n* 個の対応する参照によって表現されます。

これらの対策により、表現と対応する値の表現が上記のスキームに一致する長さプレフィックスを含む限り、将来新しい型でシリアライズ形式を拡張できます。これにより、それらを理解しない古いデシリアライザーはそれらをスキップできます。サブタイピング規則により、この状況でもアップグレード可能性が維持されます。つまり、古いデシリアライザーはエンコードされたデータを理解する必要はありません。

## 未解決の疑問

* デフォルトのフィールド値をサポートするか？
* ジェネリック型定義をサポートするか？
* インポートの名前空間？
