# Candidエンコーダー／デコーダー 実装詳細設計

## はじめに: CandidとICPキャニスター通信概要

Candidは、Internet Computer (ICP)上のスマートコントラクト（キャニスター）と外部とのインタフェースを定義・シリアライズするためのIDL（インタフェース記述言語）です。Candidメッセージは常に**魔法数**と呼ばれる4バイトのプレフィックス`DIDL`で始まり、その後に「型テーブル」「型シーケンス」「値シーケンス」の3つの部分から構成されます。本設計書では、Candidの仕様に基づき、Nim言語でICPキャニスターと通信可能なCandidエンコード／デコード処理を実装するための詳細な設計を示します。各種データ型の取り扱いやLEB128エンコーディング、型テーブル構築、テキスト形式との相互変換まで、ステップごとに丁寧に解説します。

## Candidの型システムと全対応データ型

Candidがサポートする全ての型とその分類を整理します。Candidの型は大きく**基本型**（プリミティブ）と**複合型**（コンポジット）に分かれます。Nim実装では、これら各型を表現するデータ構造と、エンコード／デコードのロジックを用意します。

### 基本型 (Primitive Types)

基本型は、それ自体で完全な値を表す組み込み型です。Candidでは以下が基本型として定義されています（括弧内はCandid内部での型コードを16進表記で示します）:

* **null (0x7F)** – 値を一切持たない単一の値型。Candidでは`null`という具体値のみを取り得ます。
* **bool (0x7E)** – 真偽値型。`true`または`false`の2値を取ります。
* **text (0x71)** – テキスト文字列型。UTF-8エンコードされた文字列としてシリアライズされます。
* **nat (0x7D)** と **int (0x7C)** – 任意精度の非負整数（nat）および符号付整数（int）型です。サイズに制限はなく、大きな値も扱えます（詳細は後述のLEB128参照）。
* **nat8 (0x7B)**, **nat16 (0x7A)**, **nat32 (0x79)**, **nat64 (0x78)** – ビット幅固定の符号なし整数型（8,16,32,64ビット）。対応する範囲の非負整数を表現し、エンコード時はリトルエンディアンの固定長バイト列になります。
* **int8 (0x77)**, **int16 (0x76)**, **int32 (0x75)**, **int64 (0x74)** – ビット幅固定の符号付整数型（8,16,32,64ビット）。値エンコードはリトルエンディアンで固定長です（例：`int32`は4バイト、`int64`は8バイト）。
* **float32 (0x73)**, **float64 (0x72)** – 32ビット単精度および64ビット倍精度の浮動小数点数型。IEEE 754形式でリトルエンディアンバイト列としてエンコードされます。
* **principal (0x68)** – プリンシパル（主体）を表す型。ICP上のユーザやキャニスターを識別するIDです。バイナリ表現では可変長のバイト列で、先頭にバイト長、続いて識別子データが格納されます（識別子にはCRC32等を含む独自フォーマットが使われますが、本設計では既存ライブラリの利用も検討します）。
* **reserved (0x70)** – 予約型。どんな型の値でもこの型に適合しうる特殊な"トップ型"です（受信側でフィールドを無視する目的で使われます）。実際の値エンコードは相手の基本型に従いますが、デコード時にこの型で受け取る場合は値を破棄または無視します。
* **empty (0x6F)** – 空型。値を一切持たない"ボトム型"で、この型を期待する場所には**何も送ってはならない**ことを意味します。emptyは通常、出現し得ない値を示すために利用されます（例えば`vec empty`は要素を絶対に持たないベクタ型として扱われ、長さは常に0になります）。

上記基本型に対して、Nimではそれぞれ以下のように対応する型ないしクラスを用意します。

* `bool`はNimの内蔵boolにマップし、`true`/`false`で表現。
* テキストはNimの`string`型で保持（UTF-8エンコード前の状態）。
* 可変長の`nat`/`int`は、Nimの`BigInt`あるいは`BiggestInt`（任意長整数）で保持し、LEB128エンコード/デコードで処理。
* 固定サイズの数値（nat8等）はNimの対応するビット幅整数（`uint8`,`uint16`等 / `int8`,`int16`等）で保持。
* 浮動小数点はNimの`float32`/`float64`で保持。
* principalは、バイト列（例えば`array[byte]`もしくはNimの`openArray[byte]`）や専用構造体として扱い、テキスト表現（`aaaaa-aa`形式など）との相互変換ロジックも別途用意します。
* reservedとemptyは特殊扱いとなるため、Nim上ではこれらを直接表す値は持ちません。**reserved**は「任意の型と互換性を持つ型」として、デコード時には値を破棄するか、例えば`nil`もしくはOptional型で「使用しない値」として処理します。**empty**はデコードで登場した時点で**不整合**（送信側が値を送ったが受信側がemptyと定義している）を意味するため、デコード処理ではエラーとして検知します。

※ **重要:** Candid仕様上、基本型と複合型には**型コード**が割り振られており、エンコード時にはそれらを**符号付きLEB128**で表現します。上記の16進値は、その型コードを符号付きLEB128エンコードした場合に現れるバイト値です。例えば、型コード-3が`nat`に対応し、そのLEB128エンコード結果が単一バイト`0x7D`になります。

### 複合型 (Composite Types)

複合型は他の型を内部に含む構造を持つ型です。Candidでは以下の複合型が定義されています。Nim実装では、複合型ごとに適切な内部表現（レコード型ならタプルやオブジェクト、ベクタ型ならシーケンス等）を用います。

* **record (0x6C)** – **レコード型**。名前付きフィールドの集合で、各フィールドに異なる型が割り当てられます。タプル（組）のように考えることもできますが、フィールドには**ハッシュ化された識別子**が付与されています（後述）。**全フィールドが必須**である点を除けば、構造体に近い型です。
* **variant (0x6B)** – **バリアント型**。いわゆるTagged Union（タグ付き和型）です。複数の代替フィールドを定義しますが、値としてはそのうち**一つだけ**が選択され、どの代替かを示すタグとともに値がエンコードされます。各代替フィールドにも名前（ハッシュ化識別子）と型があり、variant値は「どの代替が有効か」というタグと対応する値で表現します（未選択の代替フィールドは存在しないものとみなされます）。
* **opt T (0x6E)** – **オプション型**。型`T`の値を0個または1個取ることができる可変長の型です。これは実質的に「`variant { none; some: T }`」という2ケースのvariantに相当し、`null`値（値なし）または`T`の値を持ちます。Candidでは`opt T`型の値をエンコードする際、ケースをvariant同様にインデックスで示し、`0`を"値なし"（`null`に対応）、`1`を"値あり"として、その後に`T`の値を続けます。
* **vec T (0x6D)** – **ベクター型**。型`T`の要素からなる可変長配列（シーケンス）です。値としては要素数（非負整数）に続き、各要素を順にエンコードした形でシリアライズされます。文字列（text）は`vec nat8`として表現されるというように、vecは多用途に使われます。
* **func (0x6A)** – **関数参照型**。関数（キャニスターのメソッド）への参照を表す高次型です。関数のシグネチャ（引数型のタプルと戻り値型のタプル、オプションで`query`や`oneway`といった注釈）を型として定義し、値としては「あるキャニスターの特定の関数」を示す**ペア（プリンシパルID, 関数名）**で表現します。例えば`func (int) -> (int)`型の値は、「あるサービスの特定の関数へのポインタ」を意味し、実際にはprincipalと関数名文字列が送られます。
* **service (0x69)** – **サービス（オブジェクト）参照型**。キャニスター自体（またはサービスインタフェース）への参照を表す型です。内部にはメソッド一覧（メソッド名とそのシグネチャ＝func型）が定義されます。値としては**principal（キャニスターID）**だけを送り、受信側ではそれをサービス参照（Proxy）として扱います。サービス型はレコード型に似ていますが、全フィールド（メソッド）が関数である点が異なります。

**フィールド名のハッシュ:** レコード型およびバリアント型、サービス型では、それぞれのフィールド名（またはタグ名、メソッド名）は32ビット整数の**ハッシュ値**に変換され、バイナリ上では**そのハッシュID**で識別します。これはフィールド名の省略や難読化ではなく、フィールド名の変更検出や順序づけのための設計です。Candidのハッシュ関数Hは以下のように定義されています:

> H(s) = sum_{i=0 to n-1} ( s\[n-1-i] \* 223^i ) mod 2^32

すなわち、フィールド名（UTF-8のバイト列）を各バイトごとに整数と見なし、末尾のバイトから223の累乗係数を掛けて足し合わせたものの32ビット剰余として定義されます。この値が各フィールドのIDとして使われ、型テーブルではフィールド名の代わりにこの数値（をLEB128でエンコードしたもの）が記録されます。**注意:** 衝突（異なる名前が同じハッシュ値になる）は理論上起こりえますが、2^32の空間があるため**実用上は容易に避けられる**とされています。Nim実装では、このハッシュ関数をそのまま実装するか、既存のCandid実装（例えばRustやPython版）を参考に正確に再現する必要があります。

### Nimにおける複合型のデータ構造

Nimで各複合型を扱うための内部表現の一例を示します（必要に応じて調整）:

* **record**: フィールド名はバイナリ上はハッシュ化されますが、プログラム上は開発者が指定した名前で扱いたいです。そのため、Nimではレコード型に対してフィールド名と型の定義を持つオブジェクト型を用意します。または、動的にフィールド名→値のマップ（例えば`Table[string, Value]`のような構造）で保持し、シリアライズ時にハッシュ計算する戦略もあります。ここで`Value`はCandidの任意の値を保持できる共用体的な型（あるいは型クラス）とします。
* **variant**: こちらもフィールド（タグ）名と型を持ちますが、値としては**1つのタグに対する値**だけを持ちます。Nimではタグ名をキー、対応する値を持つ構造（例えば`variantValue: (tagName: string, value: Value)`）とするか、各可能性をオブジェクトのバリアントとして事前定義する方法があります。設計の柔軟性のため、動的なペア（現在のタグ名と値）で保持する方式が望ましいでしょう。
* **opt**: Nimの`options`モジュールの`Option[T]`型を使用して実装します。`opt T`は`Option[T]`として表現され、`none(T)`が`null`値（値なし）に対応し、`some(x)`が値あり（中身はT型の値）を表します。例えば`opt nat`型の値は`Option[int]`として扱い、`null`の場合は`none(int)`、値が42の場合は`some(42)`となります。実装では、Candidの`opt`型のエンコード/デコード時に`Option`型との相互変換を行います。
* **vec**: Nimの`seq[T]`（シーケンス型）または配列で保持します。長さと各要素のValueを持つので、そのままNimのsequenceにしておけばエンコード時に長さを取得し、各要素を順次エンコードできます。
* **func**: 関数参照は`(principal: Principal, methodName: string)`の組として格納します。型情報（シグネチャ）は別途保持する必要がありますが、通常Candid値としてのfuncは **untyped**（どの型の関数かはメタ情報として持つが、値自体は実行時に型チェックされない）です。ただし安全に扱うためには、Nim側でも型シグネチャを保持しておきたいので、例えば`FuncReference`構造体にprincipalとメソッド名、そして引数型リスト・戻り値型リスト・注釈の情報を持たせます。デコード時には、メッセージ内のfunc値からprincipalとメソッド名を取り出し、期待する型と一致するか（シグネチャ上）確認します。
* **service**: サービス参照は`Principal`（キャニスターID）一つで表現されます。加えて、そのサービスのインタフェース（メソッド一覧とシグネチャ）は型テーブルに記述されています。Nim側では`ServiceReference`構造体にprincipalと（可能なら）インタフェース記述（例えばメソッド名→関数シグネチャのマップ）を持たせます。デコード時に型テーブルからそのサービス型の詳細を取得し、インタフェース情報として保存します。エンコード時にはPrincipal IDだけ送ります。

## Candidバイナリ形式のエンコード仕様

Candidメッセージのバイナリ形式は、前述の通り **魔法数 + 型テーブル + 型シーケンス + 値シーケンス** で構成されます。ここでは、それぞれのパートのエンコード手順を詳述します。Nimで実装する際は、この順序に従ってバイト列を生成します。

### 魔法数（Magic Number）

メッセージの先頭4バイトは常にASCII文字列`"DIDL"`です。16進では`44 49 44 4C`に対応します。デコーダー実装では、まず最初の4バイトを読み込み、この魔法数と一致するか確認します。一致しない場合、**メッセージ形式エラー**として処理を中断します。エンコーダーでは、出力の先頭に必ずこの定数バイト列を出力します。

### 型テーブル (Type Table)

**型テーブル**は、レコード・バリアント・オプション・ベクター・関数・サービスなどの**複合型の定義**を列挙した部分です。ここには**基本型**の定義は含まれません。型テーブルは以下のようにエンコードします:

1. **エントリ数**: まず型テーブルに含める型定義エントリの数を、**Unsigned LEB128**(符号なしLEB128)でエンコードします。例えば型テーブルエントリが0個の場合、`00`となります。エントリ数を`n`とすると、型テーブル内の各型には0から`n-1`までの**インデックス**が振られます。
2. **各エントリの定義**: 続いて、複合型ごとに以下のフォーマットで型定義を出力します。エントリはインデックス0から順に並べます。各エントリは**符号付きLEB128**で表現した型コード（前述の0x6Cなど）に続き、その型に固有の追加情報を並べた形式です。

   * **record型エントリ**: `0x6C`に続けてフィールド数（ULEB128）を出力し、その後にフィールド数分だけ以下を繰り返します: **フィールドID（32ビットハッシュのULEB128）**と**フィールドの型記述（符号付きLEB128）**。フィールドの型記述は、基本型なら上述の型コード、複合型ならその型が型テーブル内で何番かを**非負整数**で指定します。フィールドは**ハッシュIDの昇順**に並べます。例えば3フィールドのレコードなら、`6C 03 <hash1> <type1> <hash2> <type2> <hash3> <type3>`のようなバイト列になります。
   * **variant型エントリ**: `0x6B`に続けて代替（タグ）数（ULEB128）、続いて各代替について**タグIDハッシュ（ULEB128）**と**値の型（符号付きLEB128）**を出力します。並び順や型指定の方法はrecordと同様ですが、variantでは将来の拡張を見越し、未使用代替の扱いなどに注意が必要です（詳細は後述のスキーマ整合性で言及）。
   * **opt型エントリ**: `0x6E`に続けて**内包する型**を符号付きLEB128で1つ出力します。例えば`opt nat`型なら`6E 7D`（0x7Dはnatの型コード）となります。`opt`は内部に1つの型を持つ単純な構造です。
   * **vec型エントリ**: `0x6D`に続けて**要素の型**を1つ（符号付きLEB128）出力します。例えば`vec text`なら`6D 71`（0x71はtextの型コード）となります。
   * **func型エントリ**: `0x6A`に続けて以下を順に出力します: **引数タイプ数（ULEB128）**、**各引数の型（符号付きLEB128）**...、**戻り値タイプ数（ULEB128）**、**各戻り値の型**...、**注釈バイト列の長さ（ULEB128）**、**各注釈バイト**...。注釈は`query`や`oneway`を示すもので、文字コード `'q'` (0x71) や `'o'` (0x6F) が使われます（例えば`query`注釈のみなら長さ1、バイト`0x71`）。複数注釈が付く場合は順不同ですが、現行仕様では`query`と`oneway`のみであり、両立しないため0個か1個です。
   * **service型エントリ**: `0x69`に続けて**メソッド数（ULEB128）**、続いてメソッド数分以下を繰り返します: **メソッド名ハッシュ（ULEB128）**と**メソッドの型（符号付きLEB128）**。メソッドの型は`func`型であり、通常は型テーブル内の別エントリ（funcエントリ）へのインデックスとして表します。メソッド名のハッシュ計算もフィールドと同様に223の累乗係数で行います（フィールド名と同じ方式）。メソッドもハッシュ値の昇順で並べます。サービス型エントリ自体は**サービスのインタフェース**を記述するのみで、実際の値（サービス参照値）はprincipalになります。
3. **エントリ間の参照**: 型テーブルエントリ内で他の型を参照する際、**基本型**や**コンパウンド型コードは負数**、**テーブル内参照は0以上のインデックス**として表現します。デコーダー側では、エントリを読み込む際にこの値をSLEB128デコードし、負なら組み込み型にマップ、非負なら型テーブル配列の該当インデックスを指すものとして解釈します。たとえば、上の例で`6C 03 ... 01 ... 7A`という部分があれば、`01`はSLEB128で+1なので**型テーブルエントリ1**を指し、`0x7A`はSLEB128で負数（実際は型コード-6のLEB表現）なので**nat16型**を指すことが読み取れます。

> **例:** `service Example : { foo: func (nat64) -> (opt text) query; }`というサービス型があった場合、型テーブルには2つのエントリが必要になります。まず`func`シグネチャのエントリ（仮に#0）が`0x6A`で始まり、引数1個（ULEB128で`01`）、型はnat64（符号付きLEB128で`0x78`）、戻り値1個（`01`）、型は`opt text`（optは複合型コードなので例えば新たなエントリ#1を参照するインデックス`01`となる）、注釈1個（`01`）、注釈バイトは`0x71`（'q'）となります。続いてserviceエントリ（#1）が`0x69`で始まり、メソッド数1（`01`）、メソッド名"foo"のハッシュ（例えば`<hashFoo>`）、型はエントリ#0（インデックス`00`）となります。このように、funcエントリとserviceエントリが相互参照する形になります（実際にはserviceエントリからfuncエントリを参照）。

Nim実装では、型テーブル構築のために以下のロジックを取ります:

* **型エントリ生成**: エンコード対象となる値列について、それぞれの値の型を検査します。値が**複合型**（またはその部分に複合型を含む）場合、該当する型定義を型テーブルに追加します。
* **重複除去**: 同一の型構造は型テーブル内で一度だけ定義します。例えば複数の値が同じ型のレコードを使う場合、型テーブルには1エントリのみ置き、全てそのインデックスを参照させます。これには、（再帰型を含めて）型を構成要素ごとに比較しハッシュ化するか、既出の型との同等性判定を行う必要があります。
* **順序**: 型テーブルに入れる順序は実装上は任意ですが、通常**深さ優先探索**等で値から必要な型を順に追加していけば問題ありません。Candid仕様上、後続の型エントリから先行するエントリを参照しても構いません（前方参照を許容）。再帰型の場合、一旦エントリを作ってインデックスを確保し、子要素の型で自身を参照することが可能です。そのため、実装では型検出時に**仮エントリ**を登録してインデックスを払い出し、再帰参照を処理することが必要になります。
* **フィールドID計算とソート**: レコード/バリアント/サービスの場合、フィールドや代替、メソッドのIDを計算し、**昇順ソート**してから型テーブルに格納します。Nimではフィールド名→型のマップを取得後、キー（名前）ごとにハッシュを計算、数値でソートしてから出力します。ハッシュ計算は前述の関数Hで行います。
* **完成した型テーブルの出力**: 上記のように構築したエントリリストを、個々にエンコードしてバイト列に連結します。最初にエントリ数`n`をULEB128で書き出し、次に各エントリ定義を書きます。

### 型シーケンス (Types Vector)

型テーブルの後には、今回メッセージで送る**値の個数**と**各値の型**が並びます。形式は以下の通りです:

1. **値の個数**: 送信する値が`m`個である場合、まずその数`m`を**ULEB128**でエンコードして出力します。この`m`は、例えば1つの関数呼び出しで引数が2つであれば2、戻り値が空タプルなら0になります。
2. **各値の型記述**: 続けて`m`個の**型記述**を順に出力します。各型記述は、型テーブル内のインデックス（0以上の整数）または基本型/複合型コード（負の整数）を**符号付きLEB128**で表現したものです。エンコード時には、値ごとにその値のCandid型を判定し、以下のように処理します:

   * 値の型が基本型の場合、その型コード（負数）をSLEB128エンコードしたバイトを出力します（例: `int32`なら0x75）。
   * 値の型が複合型の場合、まずその型が型テーブル内で何番かを確認します。型テーブル構築時にインデックスが決まっているので、その**インデックス値（0以上）**をULEB128エンコードして出力します。例えば、値が型テーブルエントリ#0の型（複合型）に対応するなら、`00`を出します。**注意:** ここでは符号無しとして出力しますが、Candidの規約上「負でない整数は型テーブル参照」とみなされます。従って、どんなに大きなインデックスであっても（2^31以上など）LEB128エンコード時にMSBが立っていても、符号付きとして解釈すれば非負である限り型テーブル参照と扱われます。実装としては、値が0以上であればそのままLEB128符号無しでエンコードし、デコーダー側ではSLEB128デコード→数値が非負→型テーブル参照とするのが簡便です。
3. 型シーケンスにより、この後に続く各値が何の型としてエンコードされているかを示します。**デコーダ**はまずこの部分を読み取り、それを元に値列を正しく解釈します。

### 値シーケンス (Values)

最後に各値自体のシリアライズが続きます。値のバイナリ表現は、その型によって以下のように決まります:

* **ブール値**: `false`は1バイト`0x00`、`true`は`0x01`でエンコードします。
* **整数値（任意長nat/int）**: LEB128符号なし／符号付きでエンコードします（後述のLEB128節を参照）。例えば`nat 300`は`AC 02`、`int -42`は`D6 7F`のようになります。値の大きさによって可変長になる点に注意します。
* **固定幅整数値（nat8～nat64, int8～int64）**: リトルエンディアンのバイト列で固定長出力します。例えば`int32 1000`は0xE8 0x03 0x00 0x00（1000のリトルエンディアン）になります。負の値は2の補数表現で格納します。
* **浮動小数点数**: IEEE 754形式のビット列をリトルエンディアンで出力します。例えば`float32 1.5`は0x00 0x00 0xC0 0x3F（IEEE754で1.5の32ビット表現）になります。
* **文字列（text）**: **UTF-8バイト列**として表現します。まず文字列長（バイト数）をULEB128で出力し、その後にUTF-8エンコード済みのバイト列をそのまま続けます。例: `"Hi"`は長さ2 (`0x02`)、続いて`0x48 0x69`が出力されます。
* **principal**: principal識別子は、内部のバイト列長を先頭1バイトで表し（0～29バイト程度）、続いてそのバイト列本体を出力します。例えば`aaaaa-aa`というPrincipal（8バイト程度）なら、先頭に8、その後8バイトのデータを書きます。詳細はICPのPrincipal仕様に準じますが、Nimではデコード時にprincipalバイト列をそのまま取り出して保持し、エンコード時には所定の長さと内容を出力します。
* **record値**: レコードは複数のフィールド値からなります。**しかし値の部分にはフィールド名やIDは含みません**。代わりに、**型テーブル内のフィールド順（ハッシュ昇順）の順番**に対応付けて、各フィールドの値のみを連続して出力します。デコーダーは対応する型テーブルエントリを参照し、フィールド順序と型を把握しているため、その順に読み取った値を当てはめます。レコード値には全てのフィールドの値が（順序通りに）含まれていなければなりません。例えば型テーブルで`record {a: int; b: bool}`がエントリ#0だった場合、値シーケンスではまず`a`のint値（LEB128符号付き）、続いて`b`のbool値（1バイト）を出力します。
* **variant値**: variantは一つの代替のみ有効です。値シーケンス上では、まず**選択された代替のインデックス**（この場合インデックスとは、型テーブル内のvariantエントリで定義される代替のソート順で0始まりの位置）をULEB128で出力し、次にその代替の値本体を続けます。例えば`variant { ok:int; err:text }`型の値が`err: "Bad"`の場合、代替`err`が2番目（インデックス1）なので`01`、続いてtext `"Bad"`の長さとバイト列を出力します。variant値には未選択代替の情報は含まれません。
* **opt値**: optは実質variantの`none`/`some`二択に相当するため、エンコードもvariant同様です。まず0または1のタグ（0=値なし、1=値あり）を出力し、1の場合は続けて内部の値をエンコードします。例えば`opt nat`値が`null`なら`00`、値が`42`なら`01 2A`（01はsomeタグ、2Aは42のLEB128）となります。
* **vec値**: ベクタは可変長配列なので、**要素数**をULEB128で出力し、続けて各要素を順番にエンコードします。例えば`vec nat8`がバイト列\[0x48,0x69]（文字"Hi"）なら、まず長さ2 (`0x02`)、続いて`0x48 0x69`を出力します。空ベクタなら長さ0のみ（`0x00`）が出ます。
* **func値**: 関数参照は**プリンシパル + 関数名**の組です。まずprincipalのバイト列長とデータを出力し、続いて関数名の長さ（UTF-8バイト数）と関数名のバイト列を出力します。例えば、あるキャニスター`p`上のメソッド名`m`への参照の場合、`<len(p)> <p_bytes> <len("m")> "m"`となります。注釈（query/oneway）は値シーケンスには含まれず、型テーブルのfunc型定義内のみに存在するメタ情報です。
* **service値**: サービス参照は**principal**のみ出力します。形式はprincipal値と同じく、先頭にバイト列長、その後ID本体です。サービス型に含まれるメソッド一覧などは型テーブルで相手に伝わっているため、値としてはIDだけで足ります。受信側はprincipalを用いてそのサービス（キャニスター）のプロキシを構築することになります。

このように、値シーケンスは**型シーケンスで宣言された型情報**に従ってシリアライズされています。デコーダーでは、あらかじめ得た各値の型をもとに適切なバイト数・LEB128読み取りを行い、対応するNim内部表現の値に変換します。

**値シーケンスの例:**
先ほど型テーブル例に挙げたHTTPレスポンスのレコード型（フィールド: body: `vec nat8`, headers: `vec empty`, status\_code: `nat16`）を、具体的な値「body="Hi, all!"、headers=\[], status\_code=200」としてエンコードするとします。型テーブルと型シーケンスは既に用意されているものとし、値シーケンス部分は以下のようになります:

* `0x01` – 引数タプル長（ここではレコード1つだけを送るため1）。
* `0x00` – 型シーケンスでの型指定（このレコードは型テーブルエントリ#0だったとするので0番を指す）※実際には型シーケンスに含まれる部分ですが、値理解のため再掲。
* **bodyフィールド値**: `"Hi, all!"`はバイト列8個なので、まず長さ8 (`0x08`)、続いて`48 69 2C 20 61 6C 6C 21`（"Hi, all!"のUTF-8コード）を出力。
* **headersフィールド値**: 空ベクタなので長さ0をULEB128で`0x00`と出力。以降に要素はありません（型は`empty`なので本来何も要素を入れられない型でもあります）。
* **status\_codeフィールド値**: 200は`nat16`なので16ビットリトルエンディアンで`0xC8 0x00`を出力（0x00C8は十進数200）。

以上で値シーケンス終わりです。この例の完全なメッセージバイト列は以下のようになります（DIDLと型テーブル部分も含む）:

```
44 49 44 4C    ; "DIDL"
03            ; 型テーブルエントリ数=3
6C 03         ; 型エントリ0: record, フィールド数=3
  A2 F5 ED 88 04 01   ; フィールドID1 (例: "body"のハッシュ) と 型=エントリ1(vec nat8)
  C6 A4 A1 98 06 02   ; フィールドID2 ("headers"ハッシュ) と 型=エントリ2(vec empty)
  9A A1 B2 F9 0C 7A   ; フィールドID3 ("status_code"ハッシュ) と 型=0x7A (nat16)
6D 7B         ; 型エントリ1: vec, 要素型=0x7B (nat8)
6D 6F         ; 型エントリ2: vec, 要素型=0x6F (empty)
01            ; 値シーケンスの値個数=1（引数が1つ）
00            ; その値の型=型テーブルエントリ0 (record)
08 48 69 2C 20 61 6C 6C 21   ; bodyフィールド: vec nat8 の長さ8と8バイト("Hi, all!")
00            ; headersフィールド: vec empty の長さ0
C8 00         ; status_codeフィールド: nat16=200
```

（上記バイト列中の値はMonicツール出力をもとにしています）

## LEB128エンコード方式と実装

Candidのエンコードでは、可変長整数値表現として**LEB128 (Little-Endian Base 128)**が多用されます。特に、型コードや型テーブル索引（符号付きLEB128）、任意長のnatやint値（それぞれ符号なし/符号付きLEB128）、サイズ情報（符号なしLEB128）など様々な箇所で使われます。Nimでこれを実装するにあたり、LEB128の原理を理解し効率よく符号化/復号する必要があります。

### 符号なしLEB128 (ULEB128)

**Unsigned LEB128**は非負整数を可変長バイト列で表すエンコード方式です。7ビットごとに区切り下位から上位へバイトを構成し、各バイトの最上位ビット（MSB）を「後続バイトがある」フラグとして使います。具体的な手順は次の通りです:

1. エンコードしたい数値の二進表現を用意します（必要なら先頭に0が残り7ビットになるまでゼロ拡張します）。
2. 下位から7ビットずつグループに分割します。各グループがこの後1バイトの下位7ビットに入ります。
3. 7ビットグループごとにバイトを作り、**下位7ビットにそのグループの値**を入れます。さらに、**上位1ビット**（8ビット目）は「後続のバイトが存在する場合」1に、最後のグループでは0に設定します。
4. 最下位（最初に取り出した）7ビットグループが**最初のバイト**として出力され、以降上位のグループのバイトを順に出力します。結果として**下位グループほど先に現れる**リトルエンディアン順になります。

数値が小さい場合は1バイトで収まります（MSBが0で終了）。例えば、0は`00`、127は`7F`(0111\_1111)です。128(0x80)のように128以上になると、下位7ビット(0)にMSB1を立てた`80`と、次のバイト`01`を出力し、全体で`80 01`となります。

**例:** 非負整数624485のULEB128エンコード:

* 624485の二進は`10011000011101100101`(20ビット)です。
* 7ビット境界までゼロ埋めすると`010011000011101100101`(21ビット)になります。
* 7ビットに区切ると `[0100110] [0001110] [1100101]` です。
* 各グループを逆順に並べ、先頭2グループにはMSB=1、最後のグループにMSB=0を付加するとバイト列は `0x26 0x8E 0xE5` となります。
* リトルエンディアン順に並べ替える（下位グループから出力する）ため、結果のエンコードは `E5 8E 26` となります。

このように、**小さい値ほど短いバイト列**になり、大きい値は7ビット単位でバイトを追加します。Nimでの実装では、例えば以下の手順で符号なしLEB128エンコード可能です:

```nim
proc uleb128Encode(x: uint64): seq[byte] =
  ## 64ビット整数を符号なしLEB128エンコードしてバイト列を返す
  result = @[]
  var value = x
  while true:
    var byteVal = value and 0x7Fu64            # 下位7ビット取得
    value = value shr 7                       # 7ビット右シフト（算術シフトでなく論理シフト）
    if value == 0:
      result.add(byte(byteVal))               # 後続なしフラグ(MSB=0)で追加
      break
    else:
      result.add(byte(byteVal or 0x80u64))    # 後続あり(MSB=1)で追加
    # ループ継続
```

任意長整数（BigInt）の場合も、同様に7ビットずつ処理していくことで実装可能です。

### 符号付きLEB128 (SLEB128)

**Signed LEB128**は負数も含めて整数を可変長で表す方式です。基本概念は符号無しと似ていますが、**2の補数表現**を利用し、最終バイトの判定条件が異なります。手順は:

1. エンコードする整数値を2進の2の補数表現にします（ビット長は7の倍数になるよう符号拡張します）。
2. そのビット列を7ビットずつ下位から分割し、順にバイトを構成します。各バイト下位7ビットはグループの値、MSBは基本的に「後続あり」フラグですが、判定条件は符号無しと異なります。
3. **判定**: 各バイトを出力した後、元の値を符号ビットごと右シフトします（負数は1埋め、正数は0埋め）。**残りの値が全て0または全て1（符号ビットに相当）になり、かつ現在のバイトの符号ビット（7ビット目）が元の値の符号と一致**した場合、そのバイトを最後としてMSB=0で出力します。そうでなければMSB=1で出力し、続けます。
4. 例えば負数の場合、無限に1で埋まるため、ある時点で「残りがすべて1」かつ今のグループのトップも1になれば終了条件を満たします。正数の場合は残りがすべて0で現在グループのトップが0になれば終了です。

**例:** -123456のSLEB128エンコード:

* 123456の二進（17ビット）を用意し符号拡張して21ビット（7ビット×3）に区切ります。
* 123456の21ビット2の補数（-123456を表す)を求めると `1111000 0111011 1000000`（各7ビット）になります。
* 7ビットグループごとにバイト化すると `[01111000] [10111011] [11000000]` ですが、符号付きの場合、負なので最終バイト（ここでは11000000）のMSBは0になります（残りビット全て1かつ符号1で終了）。
* 出力順はリトルエンディアンで逆順になるため、`C0 BB 78`がエンコード結果です。

SLEB128の実装では、符号ビットの扱いと終了判定がポイントです。Nimでの疑似コードは例えば:

```nim
proc sleb128Encode(x: int64): seq[byte] =
  ## 64ビット整数を符号付きLEB128エンコード
  result = @[]
  var value = x
  let negative = (x < 0)
  while true:
    var byteVal = value and 0x7Fi64         # 下位7ビット
    value = value shr 7                    # 算術シフト（符号ビット伝搬）
    # 符号ビットがこれから出力する値と異なるか、まだ値が残っているか判定
    if (value == 0 and (byteVal and 0x40) == 0) or (value == -1 and (byteVal and 0x40) != 0):
      result.add(byte(byteVal))            # 終了条件: MSB=0で出力してループ終了
      break
    else:
      result.add(byte(byteVal or 0x80i64)) # 続行: MSB=1で出力
```

ここで`0x40`は7ビット目(0-indexで6番目)を指し、`byteVal and 0x40`が非ゼロなら現在の値の符号ビットが1（負数を意味）です。

### Nimでのデコード

デコードはエンコード手順を逆に辿ります。**ULEB128デコード**では、1バイトずつ読み、MSBが1なら下位7ビットを累積値に加えつつ次のバイトを読み、MSBが0のバイトで終了します。**SLEB128デコード**では、同様に7ビットずつ累積しつつ、最後のバイトのMSB(符号)が1なら受け取った値を符号拡張します。すなわち、最後のバイトの7ビット目が1の場合、以降の高位ビットを全て1にセットして負数を再構成します。

Nimでは、小さな整数であれば上記を64ビットに収めますが、Candidでは任意長のnat/intも許容するため、必要に応じてビット列をBigInt（任意長整数）に詰め直す処理が必要です。幸い、LEB128自体はどんなに長くても1バイトずつ処理できるため、64ビットを超えるような場合は、ループ内で`BigInt`へシフト・加算していくアプローチで対応可能です。

## 型と値の対応関係・順序、およびスキーマ整合性

エンコードされたCandidメッセージを正しく解釈するには、**型と値の対応関係**を維持しなければなりません。送信側が出力した値シーケンスは、それに先立つ型シーケンスで宣言された型に**順序通り**対応します。Nimでデコーダを実装する際には、以下の点に注意します。

* **値順序**: Candidではメッセージ全体がタプル（複数値の組）として扱われます。例えば関数の引数が複数ある場合、それらは順番に並べられます。デコード時にはまずタプル長を取得し、その回数だけ型を読み、続いて値を読むことで、同じ順番の値リストを再現します。必ず**エンコード時と同じ順序**で取り出すことが重要です。
* **型解釈**: 各値は、それぞれ対応する型情報に基づいて解釈されます。例えば型シーケンス1番目が`int`となっていれば、値シーケンス1番目のバイト列はLEB128符号付きで読み込みNimのint型に格納します。2番目が`vec nat8`なら、値シーケンス2番目はまず長さをULEB128で取得し、その数だけバイトを読み込んで配列を構築します。実装では、**型コードやインデックスに応じて適切な読み出し関数をdispatch**させる仕組みが必要になります。
* **フィールド順序**: レコードやバリアント内部のフィールドについては、前述した通り**型テーブルでソートされた順序**が値にも反映されます。レコードでは位置対応、バリアントでは最初に選択肢インデックスが出る形で、構造を保っています。そのため、デコーダーは型テーブル中の定義順序を記憶し、例えば「レコード型#iは3フィールド（ID順）、したがってこの値はその順に3つの部分から成る」と理解して読み取ります。逆に、デコードした値を再現する際（テキスト表示等）も、元のフィールド名に対応付けるにはこの順序とIDを用いてマッピングする必要があります。
* **長さ不一致や欠損**: タプル長やベクタ長が宣言と異なる場合、デコードエラーとなります。例えば型シーケンスで値が2つとあったのに値シーケンスが1つ分しかなければ不完全ですし、逆に余分なバイトが残っていても不正です。実装では値読み取り後に**入力バッファを消費し尽くしていること**を確認し、不整合があればエラーを報告します。

### スキーマ整合性とサブタイプ互換

Candidの特徴として、**後方互換性を保つためのサブタイプ規則**が設けられています。これは、サービスインタフェースの進化（フィールド追加/削除等）において、古いデータとの互換を可能にするためのものです。NimのCandid実装でも、**受信したデータが期待する型と厳密に一致しなくとも、互換範囲であれば許容する**処理が求められます。以下に代表的なケースを挙げます。

* **レコードのフィールド追加/削除**: 古いクライアントが持つレコード型から**フィールドが削除**された場合、サーバ側（新しいスキーマ）がそのフィールドを`reserved`として定義していれば、古いクライアントからのメッセージを受け取っても無視することで許容できます。逆に、新しいクライアントでフィールドが増えた場合、古いサーバはそのフィールドを認識しませんが、`optional`で追加されていれば古いサーバは単に提供されない値として扱えます（`opt`フィールドは省略可能なので、古いサーバ側では無視する）。このように、**`reserved`や`opt`を活用する**ことでフィールドレベルの非整合を緩和できます。実装上は、デコード時に未知のフィールドハッシュが来ても無視する/格納しない、足りないフィールドはデフォルト値（オプションなら`null`）で補う、といった処理を行います。
* **variantの代替追加/削除**: variant型で新しいタグを追加するのは基本的に後方互換です（古い受信側は未知のタグを無視できないため非互換にもなり得ますが、Candidレベルではvariant値に未知タグが来ればデコードエラーにするしかありません）。削除も、本来受信側がその代替を知らなければエラーです。したがってvariantの場合、フィールドほど柔軟ではありません。指針としては、variantのケース削除は避け、未使用化する場合も`reserved`に置き換えるべきとされます。Nim実装では未知タグIDを検出したらエラーにする実装となります。
* **整数型の互換**: Candidでは`nat`は`int`のサブタイプと考えることができます。つまり、受信側が`int`型を期待しているときに送信側が`nat`値（非負の範囲で）を送った場合、それは問題なく`int`として解釈可能です。逆は負値が来る可能性があるため安全ではありません。類似に、`nat8`など小さい型の値が大きな型で受け取られる場合（例えば送信側`nat8`、受信側`nat16`）は範囲内の限り問題ありません。Nim実装では、デコード時に値が期待型に収まるかチェックし、オーバーフローするようならエラーにする、あるいはBigInt等で拡張する対応をとります。
* **オプションと非オプションの互換**: サービス進化でフィールドをオプション化したり必須化したりする場合、`T`から`opt T`への変更は後方互換です。古いクライアントは常に値を送りますが、新しいサーバはそれを`opt T`の`some`値として受け取れます。逆に`opt T`から`T`に変えるのは非互換（古いクライアントがnull送る可能性がある）なので避けるべきです。Nim実装では、受信型が`opt T`で送信が`T`の場合、自動的に`some`にラップする処理を行って互換を保つと良いでしょう（ただしCandidメッセージ上はそもそも`T`が来ることは型テーブル段階で矛盾なので、本来的には起こりません。互換性はエンコード側が担保すべきで、デコード側では基本的に一致を仮定して実装します）。
* **emptyとreserved**: 受信側が`reserved`を期待している場合、送信側のあらゆる値を受け入れて**捨てる**ことができます。実装上、デコード時に型が`reserved`であれば対応する値を読み飛ばし、何もしません（内部表現にも保持しない）。逆に受信側が`empty`の場合、送信側はその値を絶対に送ってはいけません。実装では、型テーブルに`empty`があるのに実際に値が届いた場合、即エラーとします。

以上のような互換性ルールは、Nim実装の**デコード時型チェック**で反映されます。すなわち、メッセージに含まれる型記述（送信側のタイプ）と、受信側が期待するタイプ（例えば事前に読み込んだ`.did`ファイル上の定義）が食い違う場合でも、上記サブタイプ関係に該当すれば許容または変換し、そうでなければエラーとします。これを実現するには、デコーダーに**サブタイプ判定**のロジックを組み込む必要があります（例えば型`A`が型`B`のサブタイプかを再帰的にチェックする関数）。もっとも、互換性を検証するのはアプリケーションレベルであり、単純なメッセージ解釈だけを行うライブラリ実装では基本的に「メッセージ内の型定義に従って解釈し、その結果を要求された型にマッピングする」だけでも十分です。Nim移植ではまず正確なエンコード・デコードを目指し、サブタイプの取り扱いは必要に応じ段階的に実装する方針とします。

## Candidテキスト形式との相互変換

Candidには、人間可読な**インタフェース記述ファイル（.did）**や**テキスト形式の値表現**が存在します。Nim実装では、これらテキストとの相互変換機能を組み込むことで、開発者が記述した.didファイルから自動的にエンコーダ／デコーダを生成したり、デバッグ時にバイナリをテキストにデコードしたりできるようにします。

### テキスト形式IDL（.didファイル）からのコード生成・型情報利用

`.did`ファイルはCandidのサービスインタフェースを記述したテキストファイルで、サービス名、メソッド名、各メソッドの型（引数と戻り値）、カスタム型定義（`type`キーワードによる別名やレコード/バリアント定義）などが書かれています。Nim実装では以下のように活用します:

* **.didパーサ**: まず、.didファイルを読み込み、構文解析して内部の型定義・サービス定義を抽象構文木(AST)として保持します。幸いCandidの文法は比較的シンプルで、既存実装ではANTLR4でパーサが作成されています。Nimでも独自にパーサを実装するか、PEG/正規表現を用いて文法を処理します。ポイントは、`type X = ...;`という別名/複合型定義をシンボルテーブルに登録し、最後の`service ... : { ... }`ブロックでサービスインタフェースを取得することです。
* **型定義からNim型へ**: パース結果から、各レコードやバリアントに対応するNimの型（例えばオブジェクト型やenum）を定義します。また、サービスの各メソッドに対応する関数シグネチャをNimで表現できる形（プロシージャ型など）にマッピングします。実際にNimのコードを自動生成する場合は、マクロやテンプレートを駆使して、didファイルをコンパイル時に読み込む処理も可能です。ここでは設計書の範囲なので詳細なコード生成までは踏み込みませんが、「テキストの型を内部表現の型（前述のValueツリーや専用構造）に落とし込む」部分が肝となります。
* **シリアライズ/デシリアライズ設定**: .didファイルから得られる情報（例えばメソッド`foo(arg1: int, arg2: text) -> (bool)`）に基づき、エンコード時にはその順序・型で引数を取り、前述の型テーブル～値までを生成します。デコード時には、戻り値の型に基づいてValueを適切なNim型に変換します。このマッピングには、上記ASTに対して訪問処理を書くことで対応可能です。例えば「int」というASTノードに遭遇したらNimのint（あるいはBigInt）型に変換し、エンコード関数としては`encodeInt`を呼ぶ、といった具合です。

### テキスト形式の値表現からバイナリへのエンコード

Candid値はS式に近いテキスト表現で記述できます。例えば`(42, "hello")`や`record {name="ICP"; id=42}`のような形式です。Nim実装では、この**値のテキスト表現**をパースして内部のValue構造に落とし込み、バイナリエンコードする機能を提供すると便利です。設計上のポイント:

* **文法**: Candidの値表現文法はIDLファイルと似ていますが、リテラル値が入る点が異なります。例えばタプルは`( ... )`でカンマ区切り、レコードは`record { field1 = val1; field2 = val2 }`、バリアントは`variant { Tag = val }`もしくは省略形`Tag val`が使えます。文字列はダブルクオート、数値はそのまま、true/false/nullはリテラルなど、それぞれのトークンを認識する必要があります。
* **パーサ実装**: didファイルパーサと同様に、値パーサを実装します。型情報無しで値だけ記述された場合もありますが、通常は`didc encode "<val>" -t "(型)"`のように型指定します。今回は主に**既知の型に対する値**を処理する想定とします。したがって、予め期待される型（またはサービスメソッドのシグネチャ）が分かっている状況で、その型に沿った値をパースすることで、厳密な解釈が可能です。実装では、例えば「現在読み込み中の型がrecordかどうか」でパーサ挙動を切り替え、`record { ... }`を期待するとか、型がわかっているならその型に即したリテラルを読む、といった戦略を取れます。
* **内部Value構築**: パース結果に基づき、Valueオブジェクト（前述のVariant型等の実装）を生成します。文字列リテラルはそのまま入れ、数値リテラルは桁数に応じてintかnatかを決定（もしくは外部から与えられた型ヒントに従う）、レコードはフィールド名→Valueのマップ、バリアントはタグ名とValue、オプションは`null`ならNone、値あればSome(Value)、ベクタは要素の列をパースしてリスト化、のようにします。
* **エンコード呼び出し**: こうして得たValue構造と、対応する型情報をもとに、前述の**型テーブル構築**→**型シーケンス出力**→**値シーケンス出力**処理を行い、最終的なバイト列を得ます。これを16進文字列やバイト配列として利用者に提供します。

### バイナリからテキストへのデコード表示

受信したCandidメッセージや、デバッグ用に保持しているバイト列を**可読形式に出力**する処理も有用です。didcツールの`decode`コマンドのように、バイナリから以下の情報を再構成します:

* **型テーブルの再現**: メッセージ内の型テーブルを解析し、人が読めるような型表記を生成します。例えば、型エントリ0が`record { 100_394_802: text; 142_895_325: opt table1; ... }`のように、フィールドIDをそのまま数値で表示するか、もし対応する.didファイルがあれば名前に置き換えることも考えられます。本設計では、まず単独でデコードできる仕組みとし、フィールド名は不明なので数値ハッシュをそのまま出力します。
* **値の再現**: 続いて値シーケンスを、上で得た型情報に従って読み取り、テキスト表現に直します。例えば`principal`値はそのままテキストの`"<PrincipalID>"`形式（Base32やASCII表記）にし、ベクタは`[ ... ]`もしくはテキストではタプル扱いなので`( )`で表す、recordは`record {hash1 = val1; ...}`, variantは`<TagID> = <val>`のように出します。
* **サービス/関数値の出力**: 関数参照は`func "<principal>".<method>`のような書式で表示したり、サービスは`service "<principal>"`のように出すとわかりやすいでしょう。didcでは関数やサービスも値としてはprincipal+nameなので、簡潔に`func "<principal>": "<method>"`などと表現する場合も考えられます。

デコード表示の実装では、既に実装済みのデコードロジックを使って一旦Valueツリーに落とし込み、それをテキストシリアライズするのが楽です。Valueからテキストへは、型情報も活用しつつ以下のようにします:

* 基本型のValueはそのまま文字列化（数値は10進、boolは`true`/`false`、nullは`null`、文字列はエスケープしてダブルクオート囲み）。
* recordは`record { ... }`構文で、可能ならフィールド名解決。未知の場合は`_<hash>_`のように疑似名を付ける手もあります。
* variantは`<VariantID> = ...`、未知タグなら同様に`_<hash>_`.
* vecは`vec { ... }`またはリスト表記。Candidテキストではタプル`( )`で表せるので、要素型が単一なら単に`(e1, e2, ...)`と出すだけでも良いでしょう。
* optは`null`または値を`opt <val>`と表示。didcでは`null`は表示上`null`のままですが、some値の場合`opt 5`のように出力されることがあります（または単に`5`でいい場合もあり得ますが、型情報なしだと曖昧になるので`opt`と付けたほうが親切です）。
* func, serviceは上記のようにprincipal+名前形式。

このような出力は利用者向けのデバッグ情報となります。

## おわりに: 実装の段階的戦略とテスト

以上の設計に従い、NimでCandidエンコード／デコードライブラリを構築します。まずは**基本型と簡単な複合型（opt, vec, record）**のエンコード・デコードを実装し、相互にテストします。例えば以下のようなテストケースで正しさを確認します:

* 空タプル `()` が `DIDL\0x00\0x00`とエンコードされるか。
* 単純な値 `(42 : nat)` が適切にLEB128エンコードされるか。
* レコード `{foo = true, bar = 42}`のエンコード・デコードがお互いに復元し合うか（フィールド順序とハッシュ計算が正しいか）。
* ネストした型やvecの長さ0/複数のケース。
* reservedやemptyフィールドを含む場合の挙動（値を無視する/エラーにする）が仕様通りか。
* .didファイルを読み込んで自動シリアライズできるか（例えばインポートした.didと値を与えてバイト列を生成し、それをdidcデコード結果と照合）。

特にICP上の実データ（例: 管理Canisterのインタフェースの.didと、その応答のバイナリなど）を使った相互検証を行い、他言語実装（Rustの`agent-rs`やPythonの`ic-py`）とも互換性があることを確認します。

本設計をもとに実装を進めることで、Nim上でもICPキャニスターとのやり取りをシームレスに行えるようになるでしょう。各処理ステップは独立にテスト可能であり、LEB128エンコード/デコードや型テーブル構築ロジックといった低レベル部分から、.didパースやサブタイプ検証といった高レベル部分まで、順次完成度を高めていく方針です。

**参考文献:** Candid仕様ドキュメントや既存実装のコード/解説を適宜参照し、設計の妥当性を保証します。
