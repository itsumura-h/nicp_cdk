---
description: 55-estimate-cycleブランチでの開発時に読み込む
alwaysApply: false
---
55-estimate-cycle ブランチルール
===

このブランチで実装することは以下の通りです。
- マネジメントキャニスターを呼び出す時に、cycle量を計算し、必要なだけ補充する処理を追加する
- 対象ファイル:
  - `src/nicp_cdk/canisters/management_canister/http_outcall.nim`
  - `src/nicp_cdk/canisters/management_canister/t_ecdsa.nim`

## デバッグ用実行コマンド
```bash
# t_ecdsaの例をビルド＆デプロイしてテスト
cd /application
make deploy-local-t_ecdsa
dfx canister call t_ecdsa_backend public_key '()'
dfx canister call t_ecdsa_backend sign '(record { message_hash = blob "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14\15\16\17\18\19\1a\1b\1c\1d\1e\1f" })'
```

## 進捗
- [x] `http_outcall.nim`の調査
  - [x] 現在のcycle補充処理を確認
  - [x] `estimateHttpOutcallCost`関数の動作を確認
  - [x] `ic0_cost_http_request`の使用方法を確認
- [x] `t_ecdsa.nim`の調査
  - [x] 現在のcycle補充処理を確認（定数`EcdsaCallCycles`を使用）
  - [x] `ic0_cost_sign_with_ecdsa`が使えることを確認（`ic0.nim`に宣言あり）
- [x] cycle計算処理の実装
  - [x] `http_outcall.nim`の`httpRequest`関数でcycle計算を実装
  - [x] `t_ecdsa.nim`の`publicKey`関数でcycle計算を実装
  - [x] `t_ecdsa.nim`の`sign`関数でcycle計算を実装
- [x] テストとデバッグ
  - [x] ローカルレプリカでテスト
  - [x] cycle量が適切か確認（`signWithEthereum`が正常に動作）

## 参考資料
- IC System API: https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api-imports
- `ic0_cost_http_request`: HTTPリクエストの正確なcycle量を計算
- `ic0_cost_sign_with_ecdsa`: ECDSA署名の正確なcycle量を計算
- Internet Computer開発者フォーラム: https://forum.dfinity.org
- 現在のコード:
  - `http_outcall.nim`: `estimateHttpOutcallCost`関数が存在するが、実際には使われていない
  - `t_ecdsa.nim`: 定数`EcdsaCallCycles = 26_153_846_153'u64`をハードコードして使用

### `ic0_cost_sign_with_ecdsa`の正しい使用方法（Web検索結果より）

#### 関数シグネチャ（ic0.nim）
```nim
proc ic0_cost_sign_with_ecdsa*(src: int, size: int, ecdsa_curve: uint32, dst: int): uint32
```

#### パラメータ
- `src`: ペイロードデータの先頭アドレス（Candidエンコード済み）
- `size`: ペイロードのバイトサイズ
- `ecdsa_curve`: 曲線タイプ（secp256k1 = 0, secp256r1 = 1）
- `dst`: 結果（128bit cycles）を格納するバッファのアドレス
- **戻り値**: エラーコード（0 = 成功、非0 = エラー）

#### 使用手順
1. ペイロードの準備（Candidエンコード済みデータ）
2. `ic0_cost_sign_with_ecdsa`を呼び出してcycle量を計算
3. 返されたcycle数を`ic0_call_cycles_add128`で追加
4. `sign_with_ecdsa`を実行

#### Nim実装例
```nim
proc estimateEcdsaCost(keyId: EcdsaKeyId, payload: seq[uint8]): uint64 =
  try:
    let curveValue = uint32(keyId.curve.ord)
    var costBuffer: array[16, uint8]  # 128bit for cycles
    
    let apiResult = ic0_cost_sign_with_ecdsa(
      ptrToInt(addr payload[0]),       # ペイロードの先頭アドレス
      payload.len,                     # ペイロードのサイズ
      curveValue,                      # ECDSA曲線タイプ
      ptrToInt(addr costBuffer[0])     # 結果を格納するバッファ
    )
    
    if apiResult != 0:
      return EcdsaCallCyclesFallback   # エラー時はフォールバック
    
    # 128bit値を64bitに変換
    var exactCost: uint64 = 0
    for i in 0..<8:
      exactCost = exactCost or (uint64(costBuffer[i]) shl (i * 8))
    
    return exactCost + (exactCost div 5)  # +20%マージン
  except Exception:
    return EcdsaCallCyclesFallback
```

#### 重要な注意点
- ペイロードは**Candidエンコード済み**のデータである必要がある
- APIはペイロードの内容を解析してコストを計算する可能性がある
- 実際のcycle量は`dst`バッファに128bit値として格納される
- 戻り値はエラーコードであり、cycle量ではない

## 調査結果・設計まとめ

### 実装完了した内容

1. **http_outcall.nim**:
   - 既存の`estimateHttpOutcallCost`関数を`httpRequest`関数内で使用するように修正
   - `ic0_call_cycles_add128`を使って計算したcycle量を追加
   - `ic0_cost_http_request` APIを使用して正確なcycle量を計算（20%の安全マージン込み）
   
2. **t_ecdsa.nim**:
   - 新しいヘルパー関数を追加:
     - `estimateEcdsaCost(keyId: EcdsaKeyId, payloadSize: int): uint64` - ECDSA署名・公開鍵取得共通
   - **注**: `ic0_cost_sign_with_ecdsa` APIは正しい使用方法が不明確なため、現在は使用していない
   - 代わりに、固定のベース値にペイロードサイズに応じた調整を加える方式を採用
   - 固定値`EcdsaCallCycles`を`EcdsaCallCyclesFallback`に名称変更し、ベース値として使用
   - `publicKey`関数と`sign`関数で共通のヘルパー関数を呼び出してcycleを追加
   - 引数から実際に使用するのは`key_id`のみなので、関数を共通化してコード重複を削減
   
3. **エラーハンドリング**:
   - cycle計算APIが失敗した場合（非ゼロを返した場合）のフォールバック処理を実装
   - 例外が発生した場合も同様にフォールバック値を使用
   - デバッグ用のログ出力を追加

### 技術的な注意点と今後の改善

#### 現在の実装
- `ic0_cost_ecdsa_public_key`という専用APIは存在しない
- `ic0_cost_sign_with_ecdsa`を使用する際にCandidデコードエラーが発生したため、一時的に固定値を使用
- **暫定実装**: ペイロードサイズに基づいた簡易的な推定（1000バイト以上で10%増量）

#### Web検索で判明した正しい使用方法
上記の「`ic0_cost_sign_with_ecdsa`の正しい使用方法」セクションに記載の通り、以下の点が重要：
1. ペイロードは**Candidエンコード済み**のデータを渡す（これは実装済み）
2. 戻り値はエラーコードで、cycle量は`dst`バッファに格納される（これも実装済み）
3. APIの実装例としては正しいコードを書いていた

#### エラーの原因（推測）
- ローカルレプリカの`ic0_cost_sign_with_ecdsa`実装が完全でない可能性
- 実際のメインネットやテストネットでは動作する可能性がある
- または、ペイロードの形式に何か特殊な要件がある可能性

#### 今後の改善計画
1. メインネット/テストネットで`ic0_cost_sign_with_ecdsa`を試してみる
2. 動作すれば、固定値から動的計算に切り替える
3. 現在の設計は切り替え可能になっているため、`estimateEcdsaCost`関数の中身を差し替えるだけでOK

#### その他の注意点
- Nimの特殊変数`result`とのシャドーイングを避けるため、変数名に注意
- cycle計算は常に余裕を持たせる（20%マージン推奨）

### テスト方法
ローカルレプリカでt_ecdsaの例をデプロイしてテスト:
```bash
make deploy-local-t_ecdsa
dfx canister call t_ecdsa_backend public_key '()'
dfx canister call t_ecdsa_backend sign '(record { message_hash = blob "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14\15\16\17\18\19\1a\1b\1c\1d\1e\1f" })'
```

ログ出力で以下を確認:
- `📊 Estimated ECDSA sign cost:` - 計算されたcycle量
- `Adding cycles for ECDSA public_key:` / `Adding cycles for ECDSA sign:` - 追加されるcycle量
