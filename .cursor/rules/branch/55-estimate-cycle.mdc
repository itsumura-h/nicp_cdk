---
description: 55-estimate-cycleブランチでの開発時に読み込む
alwaysApply: false
---
55-estimate-cycle ブランチルール
===

このブランチで実装することは以下の通りです。
- マネジメントキャニスターを呼び出す時に、cycle量を計算し、必要なだけ補充する処理を追加する
- 対象ファイル:
  - `src/nicp_cdk/canisters/management_canister/http_outcall.nim`
  - `src/nicp_cdk/canisters/management_canister/t_ecdsa.nim`

## デバッグ用実行コマンド
```bash
# t_ecdsaの例をビルド＆デプロイしてテスト
cd /application
make deploy-local-t_ecdsa
dfx canister call t_ecdsa_backend public_key '()'
dfx canister call t_ecdsa_backend sign '(record { message_hash = blob "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14\15\16\17\18\19\1a\1b\1c\1d\1e\1f" })'
```

## 進捗
- [x] `http_outcall.nim`の調査
  - [x] 現在のcycle補充処理を確認
  - [x] `estimateHttpOutcallCost`関数の動作を確認
  - [x] `ic0_cost_http_request`の使用方法を確認
- [x] `t_ecdsa.nim`の調査
  - [x] 現在のcycle補充処理を確認（定数`EcdsaCallCycles`を使用）
  - [x] `ic0_cost_sign_with_ecdsa`が使えることを確認（`ic0.nim`に宣言あり）
- [x] cycle計算処理の実装
  - [x] `http_outcall.nim`の`httpRequest`関数でcycle計算を実装
  - [x] `t_ecdsa.nim`の`publicKey`関数でcycle計算を実装
  - [x] `t_ecdsa.nim`の`sign`関数でcycle計算を実装
- [x] テストとデバッグ
  - [x] ローカルレプリカでテスト
  - [x] cycle量が適切か確認（`signWithEthereum`が正常に動作）
  - [x] `ic0_cost_sign_with_ecdsa`の問題を特定し、フォールバック実装に切り替え
  - [x] エラーなく署名が正常に完了することを確認

## 参考資料
- IC System API: https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api-imports
- `ic0_cost_http_request`: HTTPリクエストの正確なcycle量を計算
- `ic0_cost_sign_with_ecdsa`: ECDSA署名の正確なcycle量を計算
- Internet Computer開発者フォーラム: https://forum.dfinity.org
- 現在のコード:
  - `http_outcall.nim`: `estimateHttpOutcallCost`関数が存在するが、実際には使われていない
  - `t_ecdsa.nim`: 定数`EcdsaCallCycles = 26_153_846_153'u64`をハードコードして使用

### `ic0_cost_sign_with_ecdsa`の正しい使用方法（Web検索結果より）

#### 関数シグネチャ（ic0.nim）
```nim
proc ic0_cost_sign_with_ecdsa*(src: int, size: int, ecdsa_curve: uint32, dst: int): uint32
```

#### パラメータ
- `src`: ペイロードデータの先頭アドレス（Candidエンコード済み）
- `size`: ペイロードのバイトサイズ
- `ecdsa_curve`: 曲線タイプ（secp256k1 = 0, secp256r1 = 1）
- `dst`: 結果（128bit cycles）を格納するバッファのアドレス
- **戻り値**: エラーコード（0 = 成功、非0 = エラー）

#### 使用手順
1. ペイロードの準備（Candidエンコード済みデータ）
2. `ic0_cost_sign_with_ecdsa`を呼び出してcycle量を計算
3. 返されたcycle数を`ic0_call_cycles_add128`で追加
4. `sign_with_ecdsa`を実行

#### Nim実装例
```nim
proc estimateEcdsaCost(keyId: EcdsaKeyId, payload: seq[uint8]): uint64 =
  try:
    let curveValue = uint32(keyId.curve.ord)
    var costBuffer: array[16, uint8]  # 128bit for cycles
    
    let apiResult = ic0_cost_sign_with_ecdsa(
      ptrToInt(addr payload[0]),       # ペイロードの先頭アドレス
      payload.len,                     # ペイロードのサイズ
      curveValue,                      # ECDSA曲線タイプ
      ptrToInt(addr costBuffer[0])     # 結果を格納するバッファ
    )
    
    if apiResult != 0:
      return EcdsaCallCyclesFallback   # エラー時はフォールバック
    
    # 128bit値を64bitに変換
    var exactCost: uint64 = 0
    for i in 0..<8:
      exactCost = exactCost or (uint64(costBuffer[i]) shl (i * 8))
    
    return exactCost + (exactCost div 5)  # +20%マージン
  except Exception:
    return EcdsaCallCyclesFallback
```

#### 重要な注意点
- ペイロードは**Candidエンコード済み**のデータである必要がある
- APIはペイロードの内容を解析してコストを計算する可能性がある
- 実際のcycle量は`dst`バッファに128bit値として格納される
- 戻り値はエラーコードであり、cycle量ではない

## 調査結果・設計まとめ

### 実装完了した内容

1. **http_outcall.nim**:
   - **コンパイル時フラグ制御を実装**:
     - `estimateHttpOutcallCostDynamic()` - `ic0_cost_http_request`で動的計算
     - `estimateHttpOutcallCost()` - フラグに応じて最適な方法を選択
   - **環境適応型の実装**:
     - `-d:release`フラグ付き: `ic0_cost_http_request`で動的計算を試行
     - デフォルト: フォールバック値（50,000,000,000 cycles）を使用
   - `ic0_call_cycles_add128`を使って計算したcycle量を追加
   - 20%の安全マージンを追加してcycleを計算
   
2. **t_ecdsa.nim**:
   - **3つのヘルパー関数を追加**:
     - `isReplicatedExecution(): bool` - 実行環境を判定（レプリカ環境かローカルか）
     - `estimateEcdsaCostDynamic(keyId, payload): uint64` - `ic0_cost_sign_with_ecdsa`で動的計算
     - `estimateEcdsaCost(keyId, payload): uint64` - 環境に応じて最適な方法を選択
   - **環境適応型の実装**:
     - `ic0_in_replicated_execution()`でレプリカ環境を検出
     - レプリカ環境では`ic0_cost_sign_with_ecdsa`で動的計算を試行
     - ローカルレプリカでは最初からフォールバック値を使用
   - **堅牢なエラーハンドリング**:
     - APIエラー（戻り値非ゼロ）、計算結果が0、例外発生時にフォールバック
     - どの状況でも確実に動作する3層のフォールバック機構
   - 固定値`EcdsaCallCycles`を`EcdsaCallCyclesFallback`に名称変更し、フォールバック用として保持
   - `publicKey`関数と`sign`関数で共通のヘルパー関数を呼び出してcycleを追加
   - 引数から実際に使用するのは`key_id`のみなので、関数を共通化してコード重複を削減
   - 20%の安全マージンを追加してcycleを計算
   
3. **エラーハンドリング**:
   - cycle計算APIが失敗した場合（非ゼロを返した場合）のフォールバック処理を実装
   - 例外が発生した場合も同様にフォールバック値を使用
   - デバッグ用のログ出力を追加

### 技術的な注意点と今後の改善

#### ✅ コンパイル時フラグ制御実装（最終版）

**共通設計**:
- **コンパイル時フラグで動的計算を制御**: `-d:release`
  - **デフォルト（開発時）**: フォールバック値を使用（ローカルレプリカ対応）
  - **`-d:release`フラグ付き（本番）**: 動的計算を試行
- **安全性優先の設計**:
  - ローカルレプリカでは確実に動作するフォールバック値をデフォルト使用
  - 本番デプロイ時は`-d:release`で動的計算を自動有効化

**http_outcall.nim**:
- フォールバック値: 50,000,000,000 cycles（50 billion）
- `-d:release`時: `ic0_cost_http_request`で動的計算
- エラー時は即座にフォールバック値を使用

**t_ecdsa.nim**:
- フォールバック値: 26,153,846,153 cycles
- `-d:release`時: レプリカ環境判定後、`ic0_cost_sign_with_ecdsa`で動的計算
- **3層のフォールバック機構**（動的計算有効時）:
  1. レプリカ環境判定（`ic0_in_replicated_execution()`）
  2. `ic0_cost_sign_with_ecdsa`で動的計算
  3. APIエラー時（戻り値非ゼロ、結果が0、例外発生）はフォールバック値

#### `ic0_cost_sign_with_ecdsa`の正しい使用方法（参考）
Web検索で判明した正しい使用方法：
1. Candidエンコード済みペイロードの先頭アドレスとサイズを渡す
2. 曲線タイプ（secp256k1 = 0, secp256r1 = 1）を指定
3. 128bit cycleバッファのアドレスを渡す
4. 戻り値（エラーコード）が0なら成功、非0ならエラー
5. 成功時は取得したcycle量に20%の安全マージンを追加

#### 実装の利点
- **環境適応性**: 実行環境を自動判定し、最適な方法でcycle量を計算
- **柔軟性**: レプリカ環境ではAPIによる動的計算、ローカルでは安定したフォールバック値
- **安全性**: 3層のフォールバック機構により、あらゆる状況で動作を保証
- **保守性**: 詳細なログ出力で動作状況を確認可能
- **将来性**: ローカルレプリカの実装が改善されれば、自動的に動的計算に切り替わる
- **本番対応**: メインネット/テストネットでは正確なcycle計算が可能

#### その他の注意点
- Nimの特殊変数`result`とのシャドーイングを避けるため、変数名に注意
- cycle計算は常に余裕を持たせる（20%マージン推奨）
- ログ出力で実際に使用されたcycle量を確認可能

### テスト方法

#### ローカルレプリカでのテスト（デフォルト）
```bash
cd /application/examples/t_ecdsa
make backend && make call
```

#### メインネット/テストネットでのテスト（動的計算有効化）
`-d:release`フラグで自動的に動的計算が有効化されます:
```bash
# リリースビルド（動的計算が有効）
nim c -d:release -o:wasi.wasm src/t_ecdsa_backend/main.nim

# デプロイ
dfx deploy t_ecdsa_backend --network ic
```

注: `-d:release`は最適化フラグとしても機能するため、本番デプロイでは常に推奨されます。

ログ出力で以下を確認:
- **ローカルレプリカ**: `📊 Estimated ECDSA cost (fallback): 26153846153 cycles`
- **レプリカ環境**: `📊 Estimated ECDSA cost (dynamic): [計算値] cycles + 20% margin = [最終値] cycles`
- `Adding cycles for ECDSA public_key:` / `Adding cycles for ECDSA sign:` - 追加されるcycle量

### 環境適応型実装の動作確認

#### ローカルレプリカでのログ例
```
📊 Estimated ECDSA cost (fallback): 26153846153 cycles (payload size: 141 bytes)
Adding cycles for ECDSA public_key: 26153846153
```

#### レプリカ環境（メインネット/テストネット）での期待ログ
```
📊 Estimated ECDSA cost (dynamic): [API計算値] cycles + 20% margin = [最終値] cycles
Adding cycles for ECDSA public_key: [最終値]
```

または、APIエラー時:
```
⚠️ ic0_cost_sign_with_ecdsa returned error code: [コード], using fallback
📊 Estimated ECDSA cost (fallback): 26153846153 cycles (payload size: [サイズ] bytes)
```
