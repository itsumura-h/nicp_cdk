---
description: 
globs: 
alwaysApply: true
---
# ECDSA Public Key Args実装状況

## 目標
ICPのManagement CanisterのECDSA Public Key関数を呼ぶために必要な引数を、Candidの仕様に基づいて正しくCandidメッセージに変換する機能を実装する。

`/application/examples/ecdsa_args/src/ecdsa_args_backend/main.nim` をビルドする時は
`cd /application/examples/ecdsa_args && dfx deploy -y` コマンドを実行すること。


## Motokoの仕様
```motoko
type ecdsa_public_key_args = record {
    canister_id : opt canister_id;
    derivation_path : vec blob;
    key_id : record { curve : ecdsa_curve; name : text };
};

type ecdsa_curve = variant { 
    secp256k1; 
    secp256r1; 
};
```

## Motokoリファレンス実装
以下のMotokoコードをNimで再現することを目標とする：

```motoko
public query (msg) func ecdsa_arg() : async {
    canister_id : ?Principal;
    derivation_path : [Blob];
    key_id : { curve : { #secp256k1 }; name : Text };
  }{
    let caller = msg.caller;
    Debug.print(debug_show(caller));
    let blobCaller = Principal.toBlob(caller);
    Debug.print(debug_show(blobCaller));
    return {
      canister_id = null;
      derivation_path = [blobCaller];
      key_id = { curve = #secp256k1; name = "dfx_test_key" };
    };
  }
```

## Nimサンプルコード
最終的にはこのコードが動くようにする

```
import std/options

type EcdsaCurve {.pure.} = enum
  secp256k1 = 0
  secp256r1 = 1

proc ecdsaArgs() {.query.} =
  let caller = Msg.caller()
  let response = %*{
    "canister_id": Principal.managementCanister().some(),
    "derivation_path": @[caller.bytes],
    "key_id": {
      "curve": EcdsaCurve.secp256k1,
      "name": "dfx_test_key"
    }
  }
```

## 進捗
全てのテストケースは
- NimのコードをRecord型に変換できること
- Record型とCandid messageとのencode、decodeができること
を要件とします。

- [ ] 単体テストで実装
  - [ ] Record型でOption型を扱えること
  - [ ] Record型でPrincipal型を扱えること
  - [ ] Record型で `Option[Principal]` 型を扱えること
  - [ ] Record型で配列を扱えること
  - [ ] Record型で多重配列を再帰的にCandidRecordValueに変換できること
  - [ ] Record型でEnumを扱えること
- [ ] /application/examples/ecdsa_args/src/ecdsa_args_backend/main.nim に実装
  - [ ] ecdsaArgs関数