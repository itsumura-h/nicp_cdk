---
description: 64-upgrade-storageブランチでの開発時に読み込む
alwaysApply: false
---
Stable Memory を使ったデータベース実装
===

このブランチで実装することは以下の通りです。
- stable memoryを使って永続化可能なデータストレージを実装する
- `IcStableTable` 型（key-value store）を実装する
- `IcStableSeq` 型（配列）を実装する
- Nimの標準の `Table` 型および `seq` 型と互換性のあるAPIを提供する

## 背景

現在の実装では、グローバル変数として置いた値が永続化されず、キャニスターをアップデートするとデータが消えてしまう。
stable memoryを使用することで、キャニスターのアップグレード時にもデータを保持できるようにする。

## 進捗

- [ ] stable memory関連の基本機能を調査
- [ ] `IcStableTable` 型の設計
  - [ ] 基本的なデータ構造の設計
  - [ ] メモリレイアウトの設計（ヘッダー、インデックス、データ領域）
  - [ ] `[]` 演算子（参照・代入）の実装
  - [ ] `hasKey` 関数の実装
  - [ ] `len` 関数の実装
  - [ ] `clear` 関数の実装
  - [ ] イテレータの実装（`pairs`, `keys`, `values`）
- [ ] `IcStableSeq` 型の設計
  - [ ] 基本的なデータ構造の設計
  - [ ] メモリレイアウトの設計（長さ情報、データ領域）
  - [ ] `[]` 演算子（参照・代入）の実装
  - [ ] `len` 関数の実装
  - [ ] `add` 関数の実装
  - [ ] `delete` 関数の実装
  - [ ] イテレータの実装
- [ ] シリアライゼーション機能の実装
  - [ ] 基本型（int, uint, string, bool）のシリアライズ/デシリアライズ
  - [ ] 複合型のサポート検討
- [ ] テストコードの作成
  - [ ] `IcStableTable` の単体テスト
  - [ ] `IcStableSeq` の単体テスト
  - [ ] アップグレードテスト（データ永続性の確認）
- [ ] ドキュメントの作成
  - [ ] 使用方法のドキュメント
  - [ ] メモリレイアウトのドキュメント
  - [ ] サンプルコードの作成

## 参考資料

- [公式ドキュメント - Stable Memory](https://docs.internetcomputer.org/tutorials/developer-liftoff-rust/level-2/2.4-stable-memory)
- [stable-structures (Rust実装)](https://github.com/dfinity/stable-structures)
- [ic-nosql (TypeScript実装)](https://github.com/mycel-labs/atp/tree/main/packages/ic-nosql)
- [ic0.nim の stable memory 関数](/application/src/nicp_cdk/ic0/ic0.nim)
  - `ic0_stable64_size()`: stable memoryのページ数を取得
  - `ic0_stable64_grow(new_pages)`: stable memoryを拡張
  - `ic0_stable64_write(offset, src, size)`: stable memoryへ書き込み
  - `ic0_stable64_read(dst, offset, size)`: stable memoryから読み込み

## 調査結果・設計まとめ

### Stable Memory の基礎知識

- stable memoryはページ単位で管理される（1ページ = 64KB = 65536バイト）
- キャニスターのアップグレード時にもデータが保持される
- 通常のWASMメモリ（heap）とは別の領域

### IcStableTable の設計方針

1. **メモリレイアウト**
   - ヘッダー領域: メタデータ（要素数、容量など）
   - インデックス領域: ハッシュテーブルまたはB-tree構造
   - データ領域: キーと値のシリアライズデータ

2. **API設計**（Nimの `Table[K, V]` 型と互換）
   ```nim
   type IcStableTable*[K, V] = object
   
   proc initIcStableTable*[K, V](): IcStableTable[K, V]
   proc `[]`*[K, V](t: var IcStableTable[K, V], key: K): V
   proc `[]=`*[K, V](t: var IcStableTable[K, V], key: K, value: V)
   proc hasKey*[K, V](t: IcStableTable[K, V], key: K): bool
   proc len*[K, V](t: IcStableTable[K, V]): int
   proc clear*[K, V](t: var IcStableTable[K, V])
   iterator pairs*[K, V](t: IcStableTable[K, V]): (K, V)
   iterator keys*[K, V](t: IcStableTable[K, V]): K
   iterator values*[K, V](t: IcStableTable[K, V]): V
   ```

### IcStableSeq の設計方針

1. **メモリレイアウト**
   - ヘッダー領域: 配列の長さ、容量
   - データ領域: 要素のシリアライズデータ

2. **API設計**（Nimの `seq[T]` 型と互換）
   ```nim
   type IcStableSeq*[T] = object
   
   proc initIcStableSeq*[T](): IcStableSeq[T]
   proc `[]`*[T](s: IcStableSeq[T], idx: int): T
   proc `[]=`*[T](s: var IcStableSeq[T], idx: int, value: T)
   proc len*[T](s: IcStableSeq[T]): int
   proc add*[T](s: var IcStableSeq[T], value: T)
   proc delete*[T](s: var IcStableSeq[T], idx: int)
   iterator items*[T](s: IcStableSeq[T]): T
   ```

### シリアライゼーション方針

**重要な決定: Candidエンコード/デコードは使用しない**

既存の `candid_encode.nim` / `candid_decode.nim` は使わず、独自のシンプルなシリアライゼーションを実装する。

#### Candidを使わない理由

1. **オーバーヘッドが大きい**
   - マジックバイト `DIDL` + 型テーブルが毎回必要
   - 小さなデータでも冗長な型情報が付与される
   - stable memory内部では型が既知なので不要

2. **用途の違い**
   - Candid: キャニスター間通信のためのインターフェース定義言語
   - Stable Memory: 内部ストレージ（型は実装時に確定）

3. **パフォーマンス**
   - 直接バイト変換の方が高速
   - メモリ使用量が最小限

#### 独自シリアライゼーションの設計

**基本方針**
- 固定長型: そのままバイト列として読み書き（エンディアン考慮）
- 可変長型: 長さ情報（4バイト）+ データ本体
- 複合型: 再帰的にシリアライズ

**実装例**

```nim
# 固定長型（例: uint64）
proc serialize(value: uint64): array[8, byte] =
  var le: uint64
  littleEndian64(addr le, unsafeAddr value)
  copyMem(addr result[0], addr le, 8)

proc deserialize(data: array[8, byte]): uint64 =
  var le: uint64
  copyMem(addr le, unsafeAddr data[0], 8)
  littleEndian64(addr result, addr le)

# 可変長型（例: string）
proc serialize(value: string): seq[byte] =
  let len = uint32(value.len)
  result = newSeq[byte](4 + value.len)
  copyMem(addr result[0], unsafeAddr len, 4)
  if value.len > 0:
    copyMem(addr result[4], unsafeAddr value[0], value.len)

proc deserialize(data: openArray[byte], offset: var int): string =
  var len: uint32
  copyMem(addr len, unsafeAddr data[offset], 4)
  offset += 4
  result = newString(int(len))
  if len > 0:
    copyMem(addr result[0], unsafeAddr data[offset], int(len))
    offset += int(len)
```

**サポートする型の優先順位**

Phase 1（最小限）:
- `uint8`, `uint16`, `uint32`, `uint64`
- `int8`, `int16`, `int32`, `int64`
- `bool` (1バイト)
- `string` (長さ + データ)

Phase 2（拡張）:
- `seq[T]` (長さ + 要素の連続)
- `Option[T]` (フラグ1バイト + データ)
- タプル型

Phase 3（高度）:
- カスタム型のサポート（マクロによる自動生成）

### 技術的な課題と対策

1. **エンディアン**
   - Little-endianで統一（WASMの標準）
   - `std/endians` モジュールを使用

2. **メモリ管理**
   - 必要に応じて `ic0_stable64_grow` で自動拡張
   - 削除時の断片化対策（コンパクション機能の検討）
   - フリーリストによる空き領域の再利用

3. **パフォーマンス**
   - 頻繁なアクセスのためにキャッシュ機構の検討
   - バッチ書き込みの最適化
   - 読み込みバッファリング

4. **データ整合性**
   - チェックサム（CRC32）の追加検討
   - バージョン情報の埋め込み（将来の互換性）

### ファイル構成

```
/application/src/nicp_cdk/
  storage/
    stable_table.nim      # IcStableTable の実装
    stable_seq.nim        # IcStableSeq の実装
    serialization.nim     # シリアライゼーション機能
```
