---
description: 
globs: 
alwaysApply: true
---
このブランチでは、nicp_cdkがcandidの全ての型についてNimの型との相互変換とcandid messageとのエンコード・デコードが正しく行われる処理を作ることを目的とする。

テストは単体テストの作成と、実際にcanisterを動かしての2つの方法で行う。

## 単体テストの作成
- /application/tests/types 以下に、それぞれのcandid型についての単体テストを作成する。
  - serializeCandid関数の動作をテストする
  - candidの型をNimの型に変換して、それをcandid messageとしてエンコードして、デコードして、Nimの型に変換するという流れをテストする。
- canisterを動かしてのテスト
  - `/application/examples/arg_msg_reply/src/arg_msg_reply_backend/main.nim` に、それぞれの型の引数を受け取って、それをまた返すような関数を作成する。
  - 関数名は、その型の引数を受け取る場合は `arg{型名}` と、引数を受け取らずにレスポンスだけをチェックしたい場合は `response{型名}`とすること
  - `/application/examples/arg_msg_reply` ディレクトリに移動して、 `dfx deploy -y` を実行し、 `dfx canister call arg_msg_reply arg{型名}` を実行して、それぞれの型の引数を受け取って、それをまた返すような関数をテストする

テストを実行して成功したら、テストシナリオ一覧に進捗を記入すること。

## テストシナリオ一覧

### 基本型（Primitive Types）
- [x] **ctNull** - null値のテスト
  - [x] 単体テスト作成 (`tests/types/test_null.nim`)
  - [x] canister関数作成 (`argNull`)
  - [x] dfx call テスト

- [x] **ctBool** - boolean値のテスト
  - [x] 単体テスト作成 (`tests/types/test_bool.nim`)
  - [x] canister関数作成 (`argBool`)
  - [x] dfx call テスト

- [x] **ctNat** - 自然数のテスト
  - [x] 単体テスト作成 (`tests/types/test_nat.nim`)
  - [x] canister関数作成 (`argNat`)
  - [x] dfx call テスト

- [x] **ctInt** - 整数のテスト
  - [x] 単体テスト作成 (`tests/types/test_int.nim`)
  - [x] canister関数作成 (`argInt`)
  - [x] dfx call テスト

- [x] **ctNat8** - 8bit自然数のテスト
  - [x] 単体テスト作成 (`tests/types/test_nat8.nim`)
  - [x] canister関数作成 (`argNat8`)
  - [x] dfx call テスト

- [x] **ctNat16** - 16bit自然数のテスト
  - [x] 単体テスト作成 (`tests/types/test_nat16.nim`)
  - [x] canister関数作成 (`argNat16`)
  - [x] dfx call テスト

- [x] **ctNat32** - 32bit自然数のテスト
  - [x] 単体テスト作成 (`tests/types/test_nat32.nim`)
  - [x] canister関数作成 (`argNat32`)
  - [x] dfx call テスト

- [x] **ctNat64** - 64bit自然数のテスト
  - [x] 単体テスト作成 (`tests/types/test_nat64.nim`)
  - [x] canister関数作成 (`argNat64`)
  - [x] dfx call テスト（小さな値は動作、大きな値は制約あり）

- [x] **ctInt8** - 8bit整数のテスト
  - [x] 単体テスト作成 (`tests/types/test_int8.nim`)
  - [x] canister関数作成 (`argInt8`)
  - [x] dfx call テスト

- [x] **ctInt16** - 16bit整数のテスト
  - [x] 単体テスト作成 (`tests/types/test_int16.nim`)
  - [x] canister関数作成 (`argInt16`)
  - [x] dfx call テスト

- [x] **ctInt32** - 32bit整数のテスト
  - [x] 単体テスト作成 (`tests/types/test_int32.nim`)
  - [x] canister関数作成 (`argInt32`)
  - [ ] dfx call テスト（デシリアライゼーションエラー: Subtyping error Int32）

- [x] **ctInt64** - 64bit整数のテスト
  - [x] 単体テスト作成 (`tests/types/test_int64.nim`)
  - [x] canister関数作成 (`argInt64`)
  - [x] dfx call テスト（基本値は動作、大きな値でCanisterエラーIC0506）

- [x] **ctFloat32** - 32bit浮動小数点のテスト
  - [x] 単体テスト作成 (`tests/types/test_float32.nim`)
  - [x] canister関数作成 (`argFloat32`)
  - [x] dfx call テスト

- [x] **ctFloat64** - 64bit浮動小数点のテスト
  - [x] 単体テスト作成 (`tests/types/test_float64.nim`)
  - [x] canister関数作成 (`argFloat64`)
  - [x] dfx call テスト

- [x] **ctText** - テキスト型のテスト
  - [x] 単体テスト作成 (`tests/types/test_text.nim`)
  - [x] canister関数作成 (`argText`)
  - [x] dfx call テスト（統合テストで実装確認済み）

- [x] **ctPrincipal** - Principal型のテスト
  - [x] 単体テスト作成 (`tests/types/test_principal.nim`)
  - [x] canister関数作成 (`argPrincipal`)
  - [x] dfx call テスト

### 複合型（Composite Types）
- [x] **ctBlob** - バイナリデータ型のテスト
  - [x] 単体テスト作成 (`tests/types/test_blob.nim`)
  - [x] canister関数作成 (`argBlob`)
  - [x] dfx call テスト

- [x] **ctOpt** - Option型のテスト
  - [x] 単体テスト作成 (`tests/types/test_opt.nim`)
  - [x] canister関数作成 (`argOpt`)
  - [x] dfx call テスト（Some/Noneの両方）

- [x] **ctVec** - Vector/Array型のテスト
  - [x] 単体テスト作成 (`tests/types/test_vec.nim`)
  - [x] canister関数作成 (`argVec`, `responseVec`)
  - [x] dfx call テスト（nat16ベクターで実装完了）

- [ ] **ctRecord** - Record型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_record.nim`)
  - [ ] canister関数作成 (`argRecord`)
  - [ ] dfx call テスト

- [ ] **ctVariant** - Variant型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_variant.nim`)
  - [ ] canister関数作成 (`argVariant`)
  - [ ] dfx call テスト

### 特殊型（Special Types）
- [ ] **ctFunc** - Function型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_func.nim`)
  - [ ] canister関数作成 (`argFunc`)
  - [ ] dfx call テスト

- [ ] **ctService** - Service型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_service.nim`)
  - [ ] canister関数作成 (`argService`)
  - [ ] dfx call テスト

- [ ] **ctReserved** - Reserved型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_reserved.nim`)
  - [ ] canister関数作成 (`argReserved`)
  - [ ] dfx call テスト

- [ ] **ctEmpty** - Empty型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_empty.nim`)
  - [ ] canister関数作成 (`argEmpty`)
  - [ ] dfx call テスト

### 修飾型（Qualifier Types）
- [ ] **ctQuery** - Query型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_query.nim`)
  - [ ] canister関数作成 (`argQuery`)
  - [ ] dfx call テスト

- [ ] **ctOneway** - Oneway型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_oneway.nim`)
  - [ ] canister関数作成 (`argOneway`)
  - [ ] dfx call テスト

- [ ] **ctCompositeQuery** - CompositeQuery型のテスト
  - [ ] 単体テスト作成 (`tests/types/test_composite_query.nim`)
  - [ ] canister関数作成 (`argCompositeQuery`)
  - [ ] dfx call テスト

### 特別なテストケース（Management Canister用）
- [ ] **EcdsaPublicKeyArgs** - Management CanisterのECDSA Public Key用の複合型
  - [ ] 単体テスト作成 (`tests/types/test_ecdsa_public_key_args.nim`)
  - [ ] canister関数作成 (`argEcdsaPublicKeyArgs`)
  - [ ] dfx call テスト
  - [ ] 実際のManagement Canister呼び出しテスト

### 複合テストシナリオ
- [ ] **ネストしたRecord** - Record内にRecordが含まれる場合
- [ ] **ネストしたVariant** - Variant内にVariantが含まれる場合
- [ ] **複雑なOpt** - Option内に複合型が含まれる場合
- [ ] **混在Vec** - 異なる型が混在するVector
- [ ] **大きなデータ** - サイズが大きなBlob/Textのテスト

## 統合テスト（Integration Test）の実装方針
- `/application/tests/test_arg_msg_reply.nim` を作成し、canister callテストを自動化する
- テストの流れ：
  1. `execProcess`を使用してdfx deployコマンドを実行してcanisterをデプロイ
  2. 各Candid型について`dfx canister call`を実行してcanisterに問い合わせ
  3. レスポンスの内容を検証（正しいCandid型でレスポンスが返されることを確認）
  4. エラーハンドリング（deployやcall失敗時の適切なエラーメッセージ）
- テスト対象：
  - 実装済みの基本型（null, bool, nat, int, nat8）
  - 今後実装する全ての型
- プロセス実行時の注意：
  - テスト実行前にexamples/arg_msg_replyディレクトリに移動
  - dfx deployは`-y`フラグを使用して対話を回避
  - stdout/stderrの適切な処理とログ出力

## 進捗確認方法
- 各テストの実行: `nim c -r tests/types/test_*.nim`
- 統合テストの実行: `nim c -r tests/test_arg_msg_reply.nim` 
  - 自動的にcanisterをデプロイし、実装済みの型のcanister callテストを実行
  - **実際のテスト実行結果（36/40テスト成功）**：
    - ✅ 成功：responseNull, argBool, argNat, argInt, argNat8, argNat16, argNat32, argNat64, argInt8, argInt16, argFloat32, argFloat64, argText, argPrincipal（5種類全て成功）
    - ❌ 失敗：argInt32（全テスト：Subtyping error Int32）, argInt64（大きな値：CanisterエラーIC0506）
  - 基本型（Primitive Types）の多くは実装完了、一部に課題あり
  - Int32型のSubtyping errorとInt64大きな値の問題要調査
- canister全体テスト: `cd examples/arg_msg_reply && dfx deploy && dfx canister call arg_msg_reply_backend <function_name>`
- Management Canister最終テスト: `dfx canister call arg_msg_reply_backend argEcdsaPublicKeyArgs`

## 統合テストの機能
- `/application/tests/test_arg_msg_reply.nim` により、以下を自動化：
  1. dfx deploy -yによるcanisterの自動デプロイ
  2. 各Candid型のcanister call実行とレスポンス検証
  3. エラーハンドリングとログ出力
- 新しい型が実装された際は、統合テストにも対応するテストケースを追加すること

## 実装パターンと修正方針

### 新しいCandid型を追加する際の必須修正箇所
1. **candid_types.nim**: `newCandidValue`関数にその型のサポートを追加
   - 例: `elif T is uint16: CandidValue(kind: ctNat16, natVal: uint(value))`
2. **request.nim**: `get{TypeName}`関数を追加
   - 例: `proc getNat16*(self:Request, index:int): uint16`
3. **reply.nim**: `reply({type})`関数を追加  
   - 例: `proc reply*(msg: uint16)`
4. **main.nim**: canister関数`arg{TypeName}`を実装
5. **arg_msg_reply.did**: DIDファイルに関数定義を追加
6. **test_arg_msg_reply.nim**: 統合テストにテストケースを追加

### 単体テストの実装パターン
- `newCandidValue(値)`を使用してCandidValueを作成
- エンコードサイズの検証（固定幅型は一定、可変長型は値に依存）
- エンコード・デコードの往復テスト
- 境界値テスト（0, 最大値、特殊値）
- 複数値のテスト

### 型別の注意点
- **固定幅型** (nat8, nat16, nat32, nat64, int8, int16, int32, int64, float32, float64): 
  - エンコードサイズは固定（ヘッダー7バイト + 型サイズ）
  - `natVal`フィールドを使用（uintにキャスト）
- **可変長型** (nat, int, text, blob):
  - エンコードサイズは値に依存
  - LEB128/SLEB128エンコーディング
- **複合型** (record, variant, vec, opt):
  - ネストした構造のテストが必要
  - 型テーブルが複雑になる

### dfx callでの型注針パターン
- 引数: `'(値 : 型名)'` 例: `'(42 : nat16)'`
- レスポンス: 基本型は型注針あり、boolは型注針なし
- 大きな数値は区切り文字付き: `(1_000 : nat16)`, `(65_535 : nat16)`

### 実装時の技術的注意点
- **CandidValueの統一フィールド**: 固定幅nat型（nat8, nat16, nat32, nat64）は全て`natVal: uint`フィールドを使用
- **型キャスト**: request/replyでは適切な型キャスト（`uint8`, `uint16`等）が必要
- **エンコードサイズ計算**: 
  - DIDL0ヘッダー: 4バイト
  - 型テーブル: 基本型で3バイト（型数1 + 型ID2バイト）
  - 値部分: 型により異なる（nat8=1, nat16=2, nat32=4, nat64=8バイト）
- **統合テストのエラーハンドリング**: dfxコマンドの絶対パス使用とディレクトリ管理が重要
- **DIDファイル更新**: 新しい関数追加後は`dfx deploy`で型定義の更新確認が必要

### 既知の制約事項と課題
- `newCandidValue`は汎用関数だが、サポートしていない型は個別に追加が必要
- 統合テストは順次実行のため、大量の型追加時は実行時間が長くなる
- canister関数名は`arg{TypeName}`パターンに統一（responseパターンは特殊用途のみ）
- **nat64型の制約**: CandidValueのnatValフィールドがuint型のため、64bit値の一部でキャストによる情報損失が発生する。小さな値（42、100など）は正常動作するが、大きな値（10000000000以上）では不正確な結果となる場合がある。
- **int32型の重大な問題**: 全てのint32値でSubtyping error（wire_type: int, expect_type: int32）が発生。candidの型変換処理に根本的な問題がある可能性。
- **int64型の大きな値問題**: 1_000_000_000_000以上の値でCanisterエラー（IC0506）が発生。canister内部でのオーバーフローまたは処理限界の可能性。

## Blob型の特別な実装方針

### ICPでのBlob型表現
- **重要**: ICPのCandidメッセージでは、`blob`型は実際には`vec nat8`として表現される
- **デコード方針**: Candidメッセージからのデコード時、`vec nat8`を検出した場合は`candid types`の`ctBlob`としてデコードする
- **相互変換性**: `blob`と`vec nat8`は完全に相互変換可能
- **参考**: https://internetcomputer.org/docs/references/candid-ref#type-blob

### Blob型の実装要件

#### 1. candid_types.nimの修正
- `newCandidValue`関数でblob型（`seq[uint8]`またはバイト配列）のサポート追加
- `CandidValue`の`blobVal`フィールドを使用
- **実装方針**: 内部的には配列として扱い、エンコード時は`vec nat8`として処理
- blob専用の関数名を提供（`newCandidBlob`, `getCandidBlob`等）しつつ、実態は配列操作

#### 2. デコード処理の特別対応
- `vec nat8`パターンを検出した場合、`ctBlob`として分類
- `CandidValue(kind: ctBlob, blobVal: data)`を生成
- 他のvector型と区別するための判定ロジック実装
- **重要**: Candidメッセージ内では完全に配列として扱われ、blob特有の処理は存在しない

#### 3. テキスト表現の対応
- DIDファイルでの`blob`型の宣言: `argBlob : (blob) -> (blob);`
- dfx callでの引数指定: `blob "テストデータ"`
- UTF-8エンコーディングを使用: `blob "\CA\FF\FE"`
- ASCII文字列: `blob "Hello World"`

#### 4. エンコード・デコードのテストパターン
- 空のblob: `blob ""`
- ASCII文字列: `blob "Hello"`
- バイナリデータ: `blob "\00\01\02\03"`
- UTF-8文字列: `blob "こんにちは"`
- 大きなデータ: 1KB以上のバイナリデータ

#### 5. 単体テストの実装詳細（test_nat.nimパターンを参考）
```nim
suite "ic_blob tests":
  test "serializeCandid with small blob":
    let blobData = @[0x48u8, 0x65u8, 0x6Cu8, 0x6Cu8, 0x6Fu8] # "Hello"
    let blobValue = newCandidBlob(blobData)
    let encoded = encodeCandidMessage(@[blobValue])
    # DIDL0ヘッダー(4バイト) + 型テーブル(3バイト) + LEB128長さ(1バイト) + データ(5バイト) = 13バイト
    check encoded.len == 13

  test "serializeCandid with empty blob":
    let blobValue = newCandidBlob(@[])
    let encoded = encodeCandidMessage(@[blobValue])
    # 空のblob: DIDL0ヘッダー(4バイト) + 型テーブル(3バイト) + 長さ0(1バイト) = 8バイト
    check encoded.len == 8

  test "serializeCandid with binary data":
    let blobData = @[0x00u8, 0x01u8, 0x02u8, 0xFFu8]
    let blobValue = newCandidBlob(blobData)
    let encoded = encodeCandidMessage(@[blobValue])
    # バイナリデータのエンコードサイズを検証
    check encoded.len > 8

  test "encode and decode with ASCII blob":
    let blobData = @[0x48u8, 0x65u8, 0x6Cu8, 0x6Cu8, 0x6Fu8] # "Hello"
    let blobValue = newCandidBlob(blobData)
    let encoded = encodeCandidMessage(@[blobValue])
    let decoded = decodeCandidMessage(encoded)
    check decoded.values[0].kind == ctBlob
    check decoded.values[0].blobVal == blobData

  test "encode and decode with empty blob":
    let blobValue = newCandidBlob(@[])
    let encoded = encodeCandidMessage(@[blobValue])
    let decoded = decodeCandidMessage(encoded)
    check decoded.values[0].kind == ctBlob
    check decoded.values[0].blobVal == @[]

  test "encode and decode with large blob":
    let blobData = newSeq[uint8](mdc:1000)
    for i in 0..<1000:
      blobData[i] = uint8(i mod 256)
    let blobValue = newCandidBlob(blobData)
    let encoded = encodeCandidMessage(@[blobValue])
    let decoded = decodeCandidMessage(encoded)
    check decoded.values[0].kind == ctBlob
    check decoded.values[0].blobVal == blobData

  test "multiple blob values":
    let blobValue1 = newCandidBlob(@[0x41u8, 0x42u8]) # "AB"
    let blobValue2 = newCandidBlob(@[0x43u8, 0x44u8]) # "CD"
    let blobValue3 = newCandidBlob(@[0x45u8, 0x46u8]) # "EF"
    let encoded = encodeCandidMessage(@[blobValue1, blobValue2, blobValue3])
    let decoded = decodeCandidMessage(encoded)
    check decoded.values.len == 3
    check decoded.values[0].kind == ctBlob
    check decoded.values[0].blobVal == @[0x41u8, 0x42u8]
    check decoded.values[1].kind == ctBlob
    check decoded.values[1].blobVal == @[0x43u8, 0x44u8]
    check decoded.values[2].kind == ctBlob
    check decoded.values[2].blobVal == @[0x45u8, 0x46u8]

  test "blob value type check":
    let blobData = @[0x54u8, 0x65u8, 0x73u8, 0x74u8] # "Test"
    let blobValue = newCandidBlob(blobData)
    check blobValue.kind == ctBlob
    check blobValue.blobVal == blobData
```

#### 6. canister関数の実装パターン
```nim
proc argBlob*(data: seq[uint8]): seq[uint8] {.ic_update.} =
  # blobデータをそのまま返す
  return data

proc responseBlob*(): seq[uint8] {.ic_update.} =
  # テスト用のblobデータを返す
  return @[0x48u8, 0x65u8, 0x6Cu8, 0x6Cu8, 0x6Fu8] # "Hello"
```

#### 7. dfx callテストの実行例
```bash
# ASCII文字列のテスト
dfx canister call arg_msg_reply_backend argBlob 'blob "Hello"'

# バイナリデータのテスト  
dfx canister call arg_msg_reply_backend argBlob 'blob "\00\01\02\FF"'

# 空のblobのテスト
dfx canister call arg_msg_reply_backend argBlob 'blob ""'

# レスポンス専用テスト
dfx canister call arg_msg_reply_backend responseBlob
```

#### 8. 技術的注意点
- **メモリ効率**: 大きなblobデータの処理時はメモリ使用量に注意
- **エンコードサイズ**: blob型は可変長のため、データサイズに応じてエンコードサイズが変動
- **型判定**: `vec nat8`と`blob`の自動判定ロジックは慎重に実装
- **エラーハンドリング**: 無効なバイナリデータやサイズ制限の処理

#### 9. vec nat8との関係性
- **内部表現**: 両方とも`seq[uint8]`として扱う
- **型区別**: CandidValueのkindフィールドで区別（`ctBlob` vs `ctVec`）
- **変換ルール**: 
  - 明示的に`blob`と指定された場合 → `ctBlob`
  - `vec nat8`と指定された場合 → `ctVec`
  - デコード時の自動判定は設定可能

#### 10. 統合テストでの検証項目
- 各種データパターンでの往復変換成功
- dfx callでの引数・レスポンス形式の正確性
- エラーケースの適切な処理
- 大きなデータサイズでの性能確認
- `vec nat8`との相互変換の正確性

### Blob型の具体的な実装方針

#### API設計の基本原則
- **Candidメッセージレベル**: 完全に`vec nat8`として処理（blob特有の処理なし）
- **Nim APIレベル**: blob専用関数名で使いやすさを提供
- **内部実装**: 実態は配列操作、blob固有の処理は関数名レベルのみ

#### 関数名の設計パターン
```nim
# CandidValue作成時
proc newCandidBlob*(data: seq[uint8]): CandidValue =
  # 内部的にはvecと同じ処理だが、kindをctBlobに設定
  CandidValue(kind: ctBlob, blobVal: data)

# 値取得時
proc getBlobValue*(cv: CandidValue): seq[uint8] =
  # 内部的には配列として取得
  cv.blobVal

# Request/Replyでの取り扱い
proc getBlob*(self: Request, index: int): seq[uint8]
proc reply*(data: seq[uint8])  # blob専用オーバーロード
```

#### 実装での注意点
- **エンコード/デコード**: `vec nat8`と完全に同一の処理
- **型判定**: CandidValueのkindフィールドでのみ区別
- **メモリ効率**: 配列操作と同一のため、追加オーバーヘッドなし
- **互換性**: `vec nat8`との完全な相互変換が可能

#### コード例での実装イメージ
```nim
# 使用例：blob作成
let blobData = @[0x48u8, 0x65u8, 0x6Cu8, 0x6Cu8, 0x6Fu8]
let candidBlob = newCandidBlob(blobData)  # kindがctBlobになる

# 使用例：値取得
let retrievedData = getBlobValue(candidBlob)  # seq[uint8]として取得

# 内部処理：エンコード時はvec nat8と同じ
let encoded = serializeCandid(candidBlob)  # vec nat8として処理
```

#### vec nat8との関係性
- **メッセージレベル**: 区別不可能（同一のバイト列）
- **型情報レベル**: CandidValue.kindで区別
- **関数レベル**: 異なる関数名で利便性向上
- **実行時処理**: 完全に同一

#### 実装時の作業項目
1. **candid_types.nim**: `newCandidBlob`関数追加
2. **request.nim**: `getBlob`関数追加
3. **reply.nim**: blob用の`reply`オーバーロード追加
4. **serialization**: vec nat8と同一の処理を流用
5. **deserialization**: 型判定ロジックのみ追加

