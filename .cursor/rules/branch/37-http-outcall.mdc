37-http-outcall
===

このブランチで実装することは以下の通りです。
- ICPのHTTP Outcall機能をNimで利用可能にするためのラッパー実装
- マネジメントキャニスターのhttp_request APIの呼び出しインターフェース作成
- HTTPリクエスト/レスポンスの型定義とシリアライゼーション
- 非同期HTTPクライアントAPIの設計・実装
- エラーハンドリングとタイムアウト処理の実装
- Transform関数とレスポンス検証機能の実装

デバッグ用実行コマンド
```
cd /application/examples/http_outcall
dfx deploy -y
dfx canister call http_outcall_backend getRequest
```

## 進捗
- [x] ICPのHTTP Outcall仕様とマネジメントキャニスター経由の仕組み調査
- [x] 既存の非同期処理インフラ（management_canister.nim）の確認
- [x] HTTPリクエスト/レスポンスの型定義（CandidRecord対応）
- [x] HTTP Outcall用コールバック関数の実装
- [x] マネジメントキャニスターHTTP APIの実装
- [x] **HttpRequest → CandidRecord変換の修正と動作確認**
- [x] **非同期処理パターン（t_ecdsa踏襲）の実装と動作確認**
- [x] **エラーハンドリングとデバッグログの実装**
- [x] **Management Canister呼び出し処理の動作確認**
- [ ] Transform関数とレスポンス変換機能の実装
- [x] HTTPヘッダー、クエリパラメータ、リクエストボディの処理実装
- [x] HTTPレスポンスの解析とエラーハンドリング
- [ ] タイムアウト処理とリトライ機構の実装
- [x] **ローカルdfx制限の特定と対応策文書化**
- [x] **MotokoサンプルでのHTTP Outcall動作確認成功**
- [x] **NimとMotokoの実装ロジック比較分析完了**
- [x] **NimのCandidRecord形式をMotokoと同等に修正**
- [x] 包括的な設計書の作成 (docs/ja/refarence/httpoutcall.md)
- [x] **独自型（object、tuple、ref object）の再帰的CandidRecord変換機能を追加**

## 参考資料
- ICP HTTP Outcall仕様: https://internetcomputer.org/docs/current/developer-docs/integrations/http_requests/
- HTTPS Outcalls How it Works: https://internetcomputer.org/docs/references/https-outcalls-how-it-works
- Management Canister Interface: https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-management-canister
- HTTP Outcall Rust実装例: https://github.com/dfinity/examples/tree/master/rust/http_outcall
- Motoko HTTP Outcall実装: https://github.com/dfinity/examples/tree/master/motoko/http_outcall
- HTTP Gateway Protocol Spec: https://internetcomputer.org/docs/references/http-gateway-protocol-spec
- **設計書**: docs/ja/refarence/httpoutcall.md (包括的な実装仕様書)

## 調査結果・設計まとめ

### 実装完了状況（デバッグ結果）

#### ✅ **正常動作確認済み**

1. **CandidRecord統合**: HttpRequestの`%`演算子による正常変換
   - `newCandidRecord(request)` → `%request`への修正完了
   - uint64 → int変換によるCandidエンコード問題解決
   - 19-recordブランチの成果を活用した型安全性確保

2. **非同期処理パターン**: t_ecdsaパターンの正常な踏襲
   - main.nim: `{.update.}`で同期エクスポート、`discard controller.func()`
   - controller.nim: `{.async.}`で実装、最後に`reply()`で結果返却
   - 適切なエラーハンドリングとreject()による異常系処理

3. **Management Canister通信**: 呼び出し処理自体は成功
   - HttpRequestオブジェクト作成: ✅
   - CandidRecord変換: ✅
   - Management Canister呼び出し開始: ✅
   - 詳細デバッグログによる各段階の動作確認: ✅

#### ✅ **ローカル環境での動作確認成功**

**Motokoサンプルでの動作検証**:
- MotokoのHTTPアウトコールサンプル (`examples/http_outcall_motoko`) で正常動作確認
- Coinbase API (`api.exchange.coinbase.com`) へのHTTPリクエスト成功
- レスポンス: `("[[1682978460,5.714,5.718,5.714,5.714,243.5678]]")`
- ICP-USD価格データの正常取得確認
- **ローカルdfx環境でもHTTP Outcallは動作することが判明**

**NimとMotokoの実装ロジック比較結果**:
- アーキテクチャパターン: Nimの2層分離は適切
- ビジネスロジック: HTTP リクエスト構築からレスポンス処理まで同等
- **重要な差異発見**: CandidRecordでのOption型の表現方式
  - Motoko: `null` → 直接null値
  - Nim（修正前）: `none()` → `{"none": null}` 
  - **Nim（修正後）**: 直接null値（Motokoと同等）

**Candidエンコード形式の改善**:
- 修正前: `{"max_response_bytes": {"none": null}}` (212 bytes)
- 修正後: `{"max_response_bytes": null}` (204 bytes)
- **MotokoサンプルとCandidレコード完全一致を実現**

#### 📋 **技術的検証結果**

```nim
# 動作確認済みのHttpRequest → CandidRecord変換
proc `%`*(request: HttpRequest): CandidRecord =
  result = %* {
    "url": request.url,
    "max_response_bytes": (
      if request.max_response_bytes.isSome: 
        some(request.max_response_bytes.get.int) 
      else: 
        none(int)
    ),
    "headers": request.headers.mapIt([it[0], it[1]]),
    "body": request.body,
    "method": $request.httpMethod,
    "transform": none(CandidRecord)
  }
```

### 残存課題と次期実装予定

1. **Transform関数**: レスポンス正規化機能の実装
2. **タイムアウト処理**: リクエストタイムアウトとリトライ機構
3. **IC mainnet/testnet検証**: 実際のICネットワークでの動作確認
4. **パフォーマンス最適化**: サイクル効率とレスポンス処理速度

### 実装アーキテクチャ概要

HTTP Outcallは、ICPキャニスターが**マネジメントキャニスター**（Principal: `aaaaa-aa`）を介して外部のHTTPサーバーにリクエストを送信する機能です。

#### 通信フロー
```
ユーザーキャニスター → マネジメントキャニスター → レプリカネットワーク → 外部HTTPサーバー
                 ←                    ←                ←
```

#### 主要な制約と特徴
- **コンセンサスベース**: 複数レプリカによる結果の合意形成
- **Transform関数**: レスポンス正規化による決定論的実行
- **サイクル課金**: リクエストサイズに応じた明示的な課金
- **IPv6優先**: 直接接続とSOCKSプロキシのフォールバック機構

### 実装方針

1. **既存パターンの踏襲**: `management_canister.nim`の実装パターンを活用
2. **CandidRecord統合**: 19-recordブランチの成果を活用した型安全性確保
3. **非同期処理**: `Future[HttpResponse]`ベースのAPI設計
4. **Transform機能**: レスポンス正規化の完全サポート
5. **便利関数**: HTTPメソッド別のヘルパー関数提供

### 技術的課題

1. **マネジメントキャニスター通信**: システムキャニスターとの正確な通信プロトコル ✅
2. **Transform関数実装**: レスポンスの微細な差異を吸収する正規化処理
3. **Candidシリアライゼーション**: 複雑なCandid型の正確な処理 ✅
4. **エラーハンドリング**: 階層的なエラー型定義とコンテキスト提供 ✅

### 実装優先順位

1. **Phase 1**: HTTP Outcall型定義とCandidRecord統合 ✅
2. **Phase 2**: management_canister.nimパターンでHTTP Outcall実装 ✅
3. **Phase 3**: Transform関数サポートとコールバック処理
4. **Phase 4**: 基本的なHTTP GETリクエストの動作確認 ✅（ローカル制限あり）
5. **Phase 5**: POST/PUT等の他HTTPメソッドサポート
6. **Phase 6**: エラーハンドリングとリトライ機構 ✅
7. **Phase 7**: 便利関数とJSON統合

### 詳細設計

**包括的な実装仕様、型定義、API設計、使用例、テスト仕様等の詳細は、専用の設計書を参照してください：**

📋 **設計書**: `docs/ja/refarence/httpoutcall.md`

この設計書には以下の内容が含まれています：
- 詳細な型定義とCandidRecord統合仕様
- コールバック処理とTransform関数の実装詳細
- HTTPメソッド別便利関数のAPI仕様
- エラーハンドリングとリトライ機構
- パフォーマンス考慮事項とサイクル計算
- 包括的なテスト仕様
- 実際の使用例とベストプラクティス

実装時は設計書の仕様に従って段階的にアプローチし、各フェーズでのテストと検証を重視して信頼性の高いHTTP通信機能を実現します。 