37-http-outcall
===

このブランチで実装することは以下の通りです。
- ICPのHTTP Outcall機能をNimで利用可能にするためのラッパー実装
- マネジメントキャニスターのhttp_request APIの呼び出しインターフェース作成
- HTTPリクエスト/レスポンスの型定義とシリアライゼーション
- 非同期HTTPクライアントAPIの設計・実装
- エラーハンドリングとタイムアウト処理の実装
- Transform関数とレスポンス検証機能の実装

## 進捗
- [x] ICPのHTTP Outcall仕様とマネジメントキャニスター経由の仕組み調査
- [x] 既存の非同期処理インフラ（management_canister.nim）の確認
- [x] HTTPリクエスト/レスポンスの型定義（CandidRecord対応）
- [x] HTTP Outcall用コールバック関数の実装
- [x] マネジメントキャニスターHTTP APIの実装
- [ ] Transform関数とレスポンス変換機能の実装
- [x] HTTPヘッダー、クエリパラメータ、リクエストボディの処理実装
- [x] HTTPレスポンスの解析とエラーハンドリング
- [ ] タイムアウト処理とリトライ機構の実装
- [ ] テストケースの作成と動作確認
- [ ] ドキュメントの作成

## 参考資料
- ICP HTTP Outcall仕様: https://internetcomputer.org/docs/current/developer-docs/integrations/http_requests/
- HTTPS Outcalls How it Works: https://internetcomputer.org/docs/references/https-outcalls-how-it-works
- Management Canister Interface: https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-management-canister
- HTTP Outcall Rust実装例: https://github.com/dfinity/examples/tree/master/rust/http_outcall
- Motoko HTTP Outcall実装: https://github.com/dfinity/examples/tree/master/motoko/http_outcall
- HTTP Gateway Protocol Spec: https://internetcomputer.org/docs/references/http-gateway-protocol-spec

## 調査結果・設計まとめ

### ICPのHTTP Outcall仕様（マネジメントキャニスター経由）

HTTP Outcallは、ICPキャニスターが**マネジメントキャニスター**を介して外部のHTTPサーバーにリクエストを送信する機能です。

#### 実装アーキテクチャ
1. **ユーザーキャニスター**: HTTP Outcallを要求するキャニスター
2. **マネジメントキャニスター**: HTTP要求を実際に処理するシステムキャニスター
3. **レプリカ・ネットワーク**: 実際のHTTP通信を担当
4. **外部サーバー**: リクエスト先のHTTPサーバー

#### アーキテクチャフロー
```
ユーザーキャニスター → マネジメントキャニスター → レプリカネットワーク → 外部HTTPサーバー
                 ←                    ←                ←
```

#### マネジメントキャニスターAPI

マネジメントキャニスターは以下のAPIを提供：

```candid
// マネジメントキャニスターのCanister ID
// Principal: aaaaa-aa

type http_request_args = record {
  url : text;
  max_response_bytes : opt nat64;
  headers : vec record { text; text };
  body : opt blob;
  method : HttpMethod;
  transform : opt record {
    function : func (HttpResponse) -> (HttpResponse) query;
    context : blob;
  };
};

type HttpMethod = variant {
  get; post; head; put; delete; patch; options;
};

type HttpResponse = record {
  status : nat;
  headers : vec record { text; text };
  body : blob;
};

service : {
  http_request : (http_request_args) -> (HttpResponse);
}
```

#### 基本的な制約
- **コンセンサスベース**: 複数のレプリカが同じリクエストを実行し、結果の合意を取る
- **決定論的実行**: 全てのレプリカで同じ結果が得られる必要がある
- **サイクル消費**: HTTP Outcallの実行にはサイクル（計算リソース）が必要
- **レスポンスサイズ制限**: 最大2MBまでのレスポンスが受信可能
- **IPv6優先**: IPv6対応サーバーが推奨、IPv4はSOCKSプロキシ経由

#### Transform関数の重要性
- **目的**: 各レプリカが受信する微妙に異なるレスポンスを正規化
- **必要性**: タイムスタンプやリクエストIDなどの可変部分を除去
- **実装**: クエリメソッドとして各キャニスターが実装
- **コンセンサス**: 変換後のレスポンスが全レプリカで同一になる必要

### 実装方針

#### 1. マネジメントキャニスター通信層
- マネジメントキャニスター（Principal: `aaaaa-aa`）への呼び出し実装
- Candidシリアライゼーション/デシリアライゼーション
- サイクル管理とエラーハンドリング

#### 2. 型定義とCandidRecord統合
- `HttpRequest`、`HttpResponse`、`HttpMethod`型をCandidRecordベースで実装
- 既存のRecord型システムと統合して型安全性を確保
- Transform関数のシグネチャ定義

#### 3. 非同期API設計
- 既存のasyncfuturesモジュールとの統合
- `Future[HttpResponse]`を返すAPIの提供
- マネジメントキャニスターへの非同期呼び出し
- management_canister.nimの実装パターンを踏襲

#### 4. Transform関数サポート
- レスポンス正規化のためのTransform関数インターフェース
- 可変部分（タイムスタンプ、リクエストID等）の自動除去
- カスタムTransform関数の定義サポート

#### 5. 使いやすさの向上
- HTTPメソッド別の便利関数（`httpGet()`, `httpPost()`, `httpPut()`等）
- JSONリクエスト/レスポンスの自動処理
- クエリパラメータの自動エンコーディング
- 自動的なTransform関数の生成

#### 6. エラーハンドリング
- マネジメントキャニスターのエラー処理
- ネットワークエラー、タイムアウト、HTTPステータスエラーの分類
- 適切な例外型の定義
- リトライ機構の実装

### 想定される使用例

```nim
import nicp_cdk/http_outcall

# 基本的なGETリクエスト（Transform関数自動生成）
let response = await httpGet("https://api.example.com/data")
echo response.body

# JSONを使ったPOSTリクエスト
let jsonData = %* {"name": "Alice", "age": 30}
let response = await httpPost("https://api.example.com/users", jsonData)

# 詳細なリクエスト設定とカスタムTransform関数
proc customTransform(response: HttpResponse): HttpResponse =
  # タイムスタンプとリクエストIDを除去
  result = response
  result.headers = response.headers.filterIt(
    it[0] notin ["x-timestamp", "x-request-id"]
  )

let request = HttpRequest(
  url: "https://api.example.com/upload",
  method: HttpMethod.POST,
  headers: @[("Content-Type", "application/json")],
  body: some(jsonData.toBytes()),
  maxResponseBytes: some(1024 * 1024),  # 1MB制限
  transform: some(customTransform)
)
let response = await httpRequest(request)

# シンプルなAPI（内部でマネジメントキャニスターを呼び出し）
let weatherData = await httpGet("https://api.weather.com/current", 
  transform = removeTimestamps  # 組み込みTransform関数
)
```

### Nim実装における主要コンポーネント

#### 1. ManagementCanister型
```nim
type
  ManagementCanister* = object
    canisterId*: Principal  # aaaaa-aa

proc newManagementCanister*(): ManagementCanister =
  ManagementCanister(canisterId: Principal.fromText("aaaaa-aa"))
```

#### 2. HttpOutcall型
```nim
type
  HttpMethod* = enum
    GET = "get"
    POST = "post" 
    HEAD = "head"
    PUT = "put"
    DELETE = "delete"
    PATCH = "patch"
    OPTIONS = "options"

  HttpRequest* = object
    url*: string
    maxResponseBytes*: Option[uint64]
    headers*: seq[(string, string)]
    body*: Option[seq[byte]]
    method*: HttpMethod
    transform*: Option[proc(response: HttpResponse): HttpResponse]

  HttpResponse* = object
    status*: uint
    headers*: seq[(string, string)]
    body*: seq[byte]
```

#### 3. HTTP Outcall実行
```nim
proc httpRequest*(request: HttpRequest): Future[HttpResponse] =
  ## HTTP Outcallをマネジメントキャニスター経由で実行
  result = newFuture[HttpResponse]("httpRequest")
  
  let mgmtPrincipalBytes: seq[uint8] = @[]  # 空のbytes = management canister
  let destPtr = if mgmtPrincipalBytes.len > 0: mgmtPrincipalBytes[0].addr else: nil
  let destLen = mgmtPrincipalBytes.len
  
  let methodName = "http_request".cstring
  ic0_call_new(
    callee_src = cast[int](destPtr),
    callee_size = destLen,
    name_src = cast[int](methodName),
    name_size = methodName.len,
    reply_fun = cast[int](onHttpRequestReply),
    reply_env = cast[int](result),
    reject_fun = cast[int](onHttpRequestReject),
    reject_env = cast[int](result)
  )
  
  try:
    let candidValue = newCandidRecord(request)
    let encoded = encodeCandidMessage(@[candidValue])
    ic0_call_data_append(ptrToInt(addr encoded[0]), encoded.len)
    let err = ic0_call_perform()
    if err != 0:
      fail(result, newException(ValueError, "http_request call failed: " & $err))
  except Exception as e:
    fail(result, e)
```

### 技術的課題と解決策

#### 1. マネジメントキャニスター通信
- **課題**: システムキャニスターとの正確な通信プロトコル
- **解決**: 既存のic_typesモジュールを活用したManagementCanisterクライアント実装

#### 2. Transform関数の実装
- **課題**: レスポンスの微細な差異を吸収する正規化処理
- **解決**: 共通的な正規化パターンを組み込み関数として提供

#### 3. Candidシリアライゼーション
- **課題**: 複雑なCandid型の正確なシリアライゼーション
- **解決**: 19-recordブランチの成果を活用したCandidRecord統合

#### 4. 非同期処理との統合
- **課題**: 既存のFuture実装とHTTP Outcallの統合
- **解決**: management_canister.nimの既存パターンを活用したFutureベース実装

#### 5. エラーハンドリング
- **課題**: マネジメントキャニスターエラーとHTTPエラーの区別
- **解決**: 階層的なエラー型定義とエラーコンテキストの提供

#### 6. テスト環境
- **課題**: 外部HTTPサーバーとの通信テスト
- **解決**: モックサーバーとlocalレプリカでの統合テスト

### 実装優先順位（既存の非同期インフラを活用）

1. **Phase 1**: HTTP Outcall型定義とCandidRecord統合
2. **Phase 2**: management_canister.nimパターンでHTTP Outcall実装
3. **Phase 3**: Transform関数サポートとコールバック処理
4. **Phase 4**: 基本的なHTTP GETリクエストの動作確認
5. **Phase 5**: POST/PUT等の他HTTPメソッドサポート
6. **Phase 6**: エラーハンドリングとリトライ機構
7. **Phase 7**: 便利関数とJSON統合

### 既存インフラの活用

既存のmanagement_canister.nimファイルには、Future型を使った非同期処理のパターンが実装済みです：

- **Future[T]型**: `std/asyncfutures`モジュールの活用
- **コールバックパターン**: `onCallPublicKeyCanister`、`onCallPublicKeyReject`等
- **ic0システムコール**: `ic0_call_new`、`ic0_call_data_append`、`ic0_call_perform`
- **Candidエンコーディング**: `encodeCandidMessage`、`decodeCandidMessage`

HTTP Outcallの実装では、これらの確立されたパターンを踏襲することで、一貫性のある実装を実現します。

この設計により、NimでICPのHTTP Outcall機能を正確かつ安全に利用できるAPIを提供し、マネジメントキャニスターを介した正しいアーキテクチャと既存の非同期処理インフラに基づいた実装を実現します。 